1
00:00:08,722 --> 00:00:12,830
La ausencia de tipificación estática en
Python no significa que no haya tipos.

2
00:00:12,830 --> 00:00:16,738
En Python hay una función preconstruida
denominada "type" que te mostrará

3
00:00:16,738 --> 00:00:18,513
el tipo de una
referencia dada.

4
00:00:18,513 --> 00:00:22,890
Algunos de los tipos comunes incluyen cadenas,
el tipo "None", que discutiremos,

5
00:00:22,890 --> 00:00:25,480
Enteros y variables
de punto flotante.

6
00:00:25,480 --> 00:00:28,580
Como hemos visto, puedes también 
hacer referencia a una función,

7
00:00:28,580 --> 00:00:30,050
pues el tipo "función"
también existe.

8
00:00:31,640 --> 00:00:34,310
Los objetos con tipo tienen
propiedades asociadas, y

9
00:00:34,310 --> 00:00:37,110
estas propiedades pueden
ser datos o funciones.

10
00:00:37,110 --> 00:00:41,165
Gran cantidad de Python es construido alrededor de
diferentes tipos de secuencias o tipos de colecciones.

11
00:00:41,165 --> 00:00:45,150
Y hay tres tipos nativos de
colecciones de las que vamos a hablar

12
00:00:45,150 --> 00:00:47,710
tuplas, listas y diccionarios.

13
00:00:49,370 --> 00:00:53,028
Una tupla es una secuencia de variables.
La tupla es inmutable.

14
00:00:53,028 --> 00:00:55,851
Esto significa que una tupla tiene
elementos ordenados, pero

15
00:00:55,851 --> 00:00:58,680
no se pueden modificar
una una vez creados.

16
00:00:58,680 --> 00:01:02,968
Escribimos tuplas utilizando paréntesis, y
podemos mezclar tipos en los contenidos

17
00:01:02,968 --> 00:01:03,707
de las tuplas.

18
00:01:03,707 --> 00:01:06,380
Aquí hay una tupla que
tiene cuatro elementos.

19
00:01:06,380 --> 00:01:08,150
Dos son números y
dos son cadenas.

20
00:01:09,230 --> 00:01:11,190
Ten en cuenta que he usado
comillas simples para

21
00:01:11,190 --> 00:01:14,660
una cadena, mientras que previamente
he usado comillas dobles.

22
00:01:14,660 --> 00:01:19,390
En Python, se pueden usar comillas simples
o dobles para denotar valores de cadena.

23
00:01:21,020 --> 00:01:23,880
Las listas son muy similares, pero
pueden ser mutables, por lo que

24
00:01:23,880 --> 00:01:27,440
Puedes modificar su longitud, número y
valores de los elementos.

25
00:01:28,900 --> 00:01:31,683
Una lista se declara
usando corchetes.

26
00:01:31,683 --> 00:01:35,340
Hay un par de maneras diferentes de
cambiar el contenido de una lista.

27
00:01:35,340 --> 00:01:39,738
Uno es a través de la función "append"
que te permite añadir nuevos elementos

28
00:01:39,738 --> 00:01:40,467
 al final de la lista.

29
00:01:42,557 --> 00:01:45,175
Tanto las listas como las tuplas
son tipos iterables, por lo que

30
00:01:45,175 --> 00:01:49,340
puedes escribir bucles para ir a
través de cada uno de sus valores.

31
00:01:49,340 --> 00:01:53,760
La norma para una lista es, si deseas ver cada item,
utilizar la sentencia "for".

32
00:01:53,760 --> 00:01:58,740
Esto es similar bucle "for"
de lenguajes como Java y C #, pero

33
00:01:58,740 --> 00:02:00,700
ten en cuenta que
no se requieren tipos.

34
00:02:03,270 --> 00:02:07,360
También se puede acceder a las listas y tuplas 
como se accede a los arreglos en otros lenguajes,

35
00:02:07,360 --> 00:02:12,000
utilizando el corchete, que se
denomina operador de indexación

36
00:02:12,000 --> 00:02:15,175
El primer elemento de la lista
comienza en la posición cero y

37
00:02:15,175 --> 00:02:19,013
Para obtener la longitud de la lista,
utilizamos la función preconstruida "len".

38
00:02:19,013 --> 00:02:22,837
Hay algunas otras funciones
comunes como "min" y

39
00:02:22,837 --> 00:02:26,800
"max" que encontrarán los valores mínimos
o máximos en una lista o tupla dada.

40
00:02:28,465 --> 00:02:29,410
Las listas y tuplas de
Python también

41
00:02:29,410 --> 00:02:34,420
admiten algunas operaciones
matemáticas básicas.

42
00:02:34,420 --> 00:02:38,100
Por ejemplo, el signo
más concatena listas.

43
00:02:38,100 --> 00:02:41,380
Y los asteriscos repiten
los valores de una lista.

44
00:02:41,380 --> 00:02:45,620
Un operador muy común
es el operador "in",

45
00:02:45,620 --> 00:02:49,810
que analiza la pertenencia al conjunto y
devuelve un valor booleano de "verdadero" o

46
00:02:49,810 --> 00:02:54,770
"falso" dependiendo de si un
elemento pertenece a una lista dada.

47
00:02:54,770 --> 00:02:58,570
Vamos a trabajar más con operadores
y tipos especiales de secuencias...

48
00:02:58,570 --> 00:03:02,020
en una próxima semana, cuando veamos
una técnica llamada "broadcasting".

49
00:03:03,380 --> 00:03:08,090
Probablemente las operaciones más interesantes
que puedas hacer con las listas son las de "rebanar".

50
00:03:08,090 --> 00:03:11,920
Mientras que la sintaxis de corchetes para
acceder a un elemento puede parecer

51
00:03:11,920 --> 00:03:15,200
bastante similar a la que 
has visto en otros lenguajes,

52
00:03:15,200 --> 00:03:20,070
En Python, el operador de
indexación admite varios valores.

53
00:03:20,070 --> 00:03:22,405
El primer parámetro es,
la ubicación inicial,

54
00:03:22,405 --> 00:03:26,315
Si éste elemento es único entonces
se retorna un elemento de la lista.

55
00:03:26,315 --> 00:03:29,015
El segundo parámetro indica
el final de la rebanada,

56
00:03:29,015 --> 00:03:33,815
y es un final exclusivo. Así que si rebanaste
con el primer parámetro siendo cero...

57
00:03:33,815 --> 00:03:36,795
y el segundo parámetro siendo uno, 
entonces consigues solamente un item.

58
00:03:37,940 --> 00:03:40,580
Esto es mucho más fácil
de explicar con un ejemplo.

59
00:03:40,580 --> 00:03:44,100
Un aspecto práctico de Python
es que todas las cadenas son

60
00:03:44,100 --> 00:03:48,770
simplemente listas de caracteres, por lo tanto
el rebanado funciona maravillosamente en ellas.

61
00:03:48,770 --> 00:03:49,960
Pero la ciencia forense no es muy buena determinando Mens Rea, la intención.

62
00:03:49,960 --> 00:03:57,320
Cuando ejecutamos X sub 0 o X sub 0: 1
obtendremos sólo el primer carácter de la cadena.

63
00:03:57,320 --> 00:04:02,240
Pero cuando ejecutamos X sub 0: 2, obtenemos
los dos primeros caracteres de la cadena.

64
00:04:03,350 --> 00:04:07,210
Nuestros valores de indexación también pueden
ser negativos, lo cual es realmente genial.

65
00:04:07,210 --> 00:04:10,465
Y eso significa indexar desde
el final de la cadena.

66
00:04:10,465 --> 00:04:16,799
Así X sub -1 obtiene la última letra
de la cadena, y X sub -4, -2

67
00:04:16,799 --> 00:04:21,815
toma los caracteres desde el 4to
hasta el 2do comenzando desde el  último.

68
00:04:22,885 --> 00:04:25,245
Finalmente, si queremos
referenciar el inicio o

69
00:04:25,245 --> 00:04:29,910
el final de la cadena implícitamente, podemos 
simplemente dejar el parámetro vacío.

70
00:04:29,910 --> 00:04:35,584
Así X sub :3 comienza con el primer
carácter y va hasta la posición tres.

71
00:04:35,584 --> 00:04:40,502
Y X sub 3: comienza con el cuarto carácter,
porque la indexación siempre comienza...

72
00:04:40,502 --> 00:04:43,050
desde cero y va hasta
el final de la lista.

73
00:04:44,290 --> 00:04:46,910
El "rebanado" (slicing) es 
fundamental en Python y

74
00:04:46,910 --> 00:04:50,330
es también una gran parte de la
computación científica con Python.

75
00:04:50,330 --> 00:04:53,480
Especialmente si empiezas
a manipular matrices.

76
00:04:53,480 --> 00:04:56,370
Hablaremos más sobre el
"rebanado" en el módulo siguiente.

77
00:04:56,370 --> 00:04:58,345
Pero he aquí hay una pregunta
para que comiences.

78
00:05:00,499 --> 00:05:04,940
Ahora me estoy yendo un poco de tema
para hablar sobre manipulación de cadenas.

79
00:05:04,940 --> 00:05:07,450
El "rebanado" no es la única
manera de manipular cadenas

80
00:05:07,450 --> 00:05:10,990
Y una actividad común es partir cadenas
basándanos en subcadenas.

81
00:05:10,990 --> 00:05:13,360
Es decir, ir a través de una
cadena buscando patrones,

82
00:05:13,360 --> 00:05:15,880
y segmentarla
según corresponda.

83
00:05:15,880 --> 00:05:18,330
A esto se lo conoce como 
evaluación de expresiones regulares, y

84
00:05:18,330 --> 00:05:22,170
vamos a cubrir esto en detalle en la sección
de la especialización que trata

85
00:05:22,170 --> 00:05:25,860
con la minería de texto ya
que es una operación muy común.

86
00:05:25,860 --> 00:05:28,387
Pero Python tiene algunas herramientas
básicas para el análisis de texto.

87
00:05:28,387 --> 00:05:29,800
Y aquí te las
voy a mostrar.

88
00:05:31,490 --> 00:05:34,800
Como hemos visto, las cadenas
son simples listas de caracteres.

89
00:05:34,800 --> 00:05:38,800
Así que las operaciones que se pueden hacer
en una lista, también se pueden hacer en una cadena.

90
00:05:38,800 --> 00:05:43,260
Esto significa que puedes concatenar dos
cadenas utilizando el operador de suma.

91
00:05:43,260 --> 00:05:46,730
Y la multiplicación de cadenas ,
repetirá una cadena dada.

92
00:05:46,730 --> 00:05:50,080
Incluso puedes buscar
cadenas con el operador "in".

93
00:05:51,380 --> 00:05:54,047
El tipo cadena tiene asociada
una función llamada "split".

94
00:05:55,240 --> 00:06:00,530
Esta función divide una cadena en
sub-subcadenas basándose en un simple patrón.

95
00:06:00,530 --> 00:06:01,810
Aquí, por ejemplo,

96
00:06:01,810 --> 00:06:06,030
voy a dividir mi nombre completo basandome
en la presencia de un carácter de espacio.

97
00:06:06,030 --> 00:06:08,420
El resultado es una
lista de cuatro elementos.

98
00:06:08,420 --> 00:06:12,510
Podemos elegir el primer elemento utilizando el
operador de indexación para que sea el primer nombre,

99
00:06:12,510 --> 00:06:14,060
y el último elemento para
que sea mi apellido.

100
00:06:15,890 --> 00:06:18,570
Vamos a seguir un poco más con
las cadenas, pero antes de continuar,

101
00:06:18,570 --> 00:06:20,234
quiero hablar acerca
de los diccionarios.

102
00:06:20,234 --> 00:06:23,923
Los diccionarios se asimilan a las listas y tuplas
por el hecho de que contienen una colección de

103
00:06:23,923 --> 00:06:28,110
elementos, pero se trata de colecciones
etiquetadas que no tienen un orden.

104
00:06:28,110 --> 00:06:31,430
Esto significa que por cada
valor que insertas en el diccionario,

105
00:06:31,430 --> 00:06:34,490
debes también proveer una
clave de acceso a dicho valor.

106
00:06:34,490 --> 00:06:37,130
En otros lenguajes a esta estructura
se la suele llamar "mapa".

107
00:06:37,130 --> 00:06:40,940
Y en Python usamos llaves
para denotar un diccionario.

108
00:06:40,940 --> 00:06:44,710
Aquí tenemos un ejemplo donde vinculamos
nombres a direcciones de correo electrónico.

109
00:06:44,710 --> 00:06:48,580
Puedes ver que para crear cada
elemento del diccionario

110
00:06:48,580 --> 00:06:51,485
utilizamos pares de valores
separados por "dos puntos".

111
00:06:51,485 --> 00:06:55,520
Luego puedes recuperar un valor para una
etiqueta dada usando el operador de indexación.

112
00:06:56,820 --> 00:07:00,349
Los índices o valores del diccionario
pueden ser de cualquier tipo.

113
00:07:00,349 --> 00:07:02,870
Podría ser una mezcla
de tipos si así lo quisieras.

114
00:07:03,880 --> 00:07:07,700
Podemos agregar nuevos elementos al diccionario
mediante el mismo operador de indexación

115
00:07:07,700 --> 00:07:08,910
que estamos
acostumbrados a usar.

116
00:07:08,910 --> 00:07:10,640
simplemente en el lado
izquierdo de una sentencia.

117
00:07:11,800 --> 00:07:16,420
En un diccionario puedes iterar sobre
todos los elementos de varias maneras.

118
00:07:16,420 --> 00:07:18,910
En primer lugar, se puede iterar
sobre todas las claves y

119
00:07:18,910 --> 00:07:20,810
simplemente extraer
el contenido.

120
00:07:21,850 --> 00:07:25,190
O puedes iterar sobre los
valores e ignorar las claves.

121
00:07:26,840 --> 00:07:29,530
Finalmente se puede iterar
sobre los valores y

122
00:07:29,530 --> 00:07:31,950
claves simultáneamente a
través de la función "items".

123
00:07:33,550 --> 00:07:35,930
Este último ejemplo
es un poco diferente.

124
00:07:35,930 --> 00:07:38,760
Es un ejemplo de algo
que se llama "desempaquetar"

125
00:07:38,760 --> 00:07:42,470
En Python puedes tener una secuencia,
sea una lista o una tupla de valores, y

126
00:07:42,470 --> 00:07:47,010
puedes "desempaquetar" sus elementos
en diferentes variables mediante la asignación en

127
00:07:47,010 --> 00:07:48,480
una sentencia.

128
00:07:48,480 --> 00:07:51,830
He aquí otro ejemplo de lo mismo,
en donde tenemos una tupla que tiene mi nombre,

129
00:07:51,830 --> 00:07:53,840
apellido y dirección
de correo electrónico.

130
00:07:53,840 --> 00:07:56,960
Declaro tres variables
y las asigno a la tupla.

131
00:07:56,960 --> 00:07:59,330
Por detrás, Python ha
desempaquetado la tupla y

132
00:07:59,330 --> 00:08:02,000
asignado en orden sus valores a
cada una de las variables.

133
00:08:02,000 --> 00:08:04,470
Podemos ver que si añadimos un
cuarto elemento a la tupla,

134
00:08:04,470 --> 00:08:07,280
Python no está seguro de cómo desempaquetarlo,
así que tenemos un error.

135
00:08:08,660 --> 00:08:11,020
Esto ha sido una descripción de
los tipos incorporados en Python

136
00:08:12,060 --> 00:08:15,390
En la próxima lección, vamos a
regresar brevemente al tema de cadenas,

137
00:08:15,390 --> 00:08:16,980
luego comenzaremos a trabajar
con algunos archivos de datos.