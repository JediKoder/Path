1
00:00:08,779 --> 00:00:12,230
DataFrame數據結構是Pandas的核心。

2
00:00:12,230 --> 00:00:15,450
這將是你的主要對象，在處理數據分析

3
00:00:15,450 --> 00:00:16,110
和數據清理任務的時候。

4
00:00:17,380 --> 00:00:20,916
DataFrame在概念上是一個二維列表(series)對象，

5
00:00:20,916 --> 00:00:25,890
其中有一個索引(index)和多列內容，每列(column)都有一個標籤(label)。

6
00:00:25,890 --> 00:00:28,293
事實上，列(column)和行(row)之間的區別

7
00:00:28,293 --> 00:00:30,766
實際上只是一個概念上的區別。

8
00:00:30,766 --> 00:00:34,951
你可以將DataFrame本身視為簡單的雙軸有標籤的陣列。

9
00:00:36,550 --> 00:00:38,630
你可以以許多不同的方式創建一個DataFrame，

10
00:00:38,630 --> 00:00:40,610
其中一些你可能想像的到。

11
00:00:40,610 --> 00:00:42,890
例如，你可以使用一組列表(series)，

12
00:00:42,890 --> 00:00:45,119
其中每個列表代表一行數據。

13
00:00:45,119 --> 00:00:46,957
或者你可以使用一組字典(dictionary)，

14
00:00:46,957 --> 00:00:49,120
其中每個字典都代表一行數據。

15
00:00:50,370 --> 00:00:52,400
我們來看一個例子。

16
00:00:52,400 --> 00:00:55,650
我將創建三個採購訂單記錄作為列表對象。

17
00:00:55,650 --> 00:00:57,860
在一個虛構的商店。

18
00:00:57,860 --> 00:00:59,860
每個列表都有一個客戶名稱，

19
00:00:59,860 --> 00:01:04,430
描述要購買的商品的字串(string)，以及商品的費用。

20
00:01:04,430 --> 00:01:07,150
我喜歡狗，所以我會買一堆狗食。 

21
00:01:07,150 --> 00:01:10,510
凱文·柯林斯·湯普森，系列中，第三個課程的講師

22
00:01:10,510 --> 00:01:14,630
他似乎更像是對我來說，喜歡貓的人，所以我會讓他購買一些貓咪的沙子。

23
00:01:14,630 --> 00:01:17,600
我認為維諾德，教本系列的第四個課程，

24
00:01:17,600 --> 00:01:20,210
更是一個喜歡鳥的人，所以我會在那裡添加一些鳥吃的種子。

25
00:01:21,780 --> 00:01:25,283
然後，我們將它們作為第一個參數提供給DataFrame，

26
00:01:25,283 --> 00:01:29,112
並設置索引值(index)，代表每個購買的商店。

27
00:01:29,112 --> 00:01:32,448
你會看到，當我們打印出一個DataFrame時，Jupyter筆記本試圖

28
00:01:32,448 --> 00:01:35,160
將其漂亮一些，並將其作為表格列印出來，這是很好的。

29
00:01:36,720 --> 00:01:41,370
與列表(series)類似，我們可以使用iloc和loc屬性提取數據。

30
00:01:41,370 --> 00:01:44,850
因為DataFrame是二維的，所以將單一值傳遞給loc

31
00:01:44,850 --> 00:01:48,830
索引操作將返回一個列表，如果只有一行返回。

32
00:01:50,370 --> 00:01:53,300
在這個例子中，如果我們想要選擇與Store2關聯的數據，

33
00:01:53,300 --> 00:01:56,110
那麼我們只用一個參數查詢loc屬性(attribute)。

34
00:01:57,460 --> 00:02:01,090
你將注意到，列表的名稱作為行索引值返回，

35
00:02:01,090 --> 00:02:03,440
而列名(column_name)也包括在輸出中。

36
00:02:04,630 --> 00:02:09,517
我們可以使用python類型(type)函數檢查返回的數據類型。

37
00:02:09,517 --> 00:02:12,636
重要的是要記住，索引(index)和

38
00:02:12,636 --> 00:02:17,980
列(row)名稱，沿著任何一軸，水平或垂直方向的，可能不必是唯一的。

39
00:02:17,980 --> 00:02:21,240
例如，在這個例子中，我們看到兩個採購記錄

40
00:02:21,240 --> 00:02:23,770
在Store1是不同的行。

41
00:02:23,770 --> 00:02:27,470
如果我們用單一值在DataFrame的loc屬性，多行

42
00:02:27,470 --> 00:02:31,110
的DataFrame將返回，不是新的列表，而是新的DataFrame。

43
00:02:32,710 --> 00:02:35,729
例如，如果我們查詢Store1記錄，

44
00:02:35,729 --> 00:02:39,868
我們會看到Chris和Kevin都在同一個寵物用品商店購物。

45
00:02:39,868 --> 00:02:43,737
Pandas的DataFrame的一個功能，就是可以快速的選擇數據

46
00:02:43,737 --> 00:02:45,370
在多重軸上

47
00:02:45,370 --> 00:02:49,534
例如，如果你只想列出Store1的費用，你將提供

48
00:02:49,534 --> 00:02:53,961
兩個參數給.loc，一個為行(row)索引，另一個為列名(column)。

49
00:02:53,961 --> 00:02:58,920
如果我們只對Store 1的費用感興趣，我們可以把它寫成 df.loc['Store 1',

50
00:02:58,920 --> 00:02:59,690
'Cost']

51
00:03:01,260 --> 00:03:03,790
如果我們只想做列(row)選擇，

52
00:03:03,790 --> 00:03:06,170
並且只取所有費用的清單怎麼辦？

53
00:03:06,170 --> 00:03:07,870
那麼有幾個選擇。

54
00:03:07,870 --> 00:03:10,142
首先，你可以首先獲取DataFrame的轉置使用大寫T屬性

55
00:03:10,142 --> 00:03:14,260
，該屬性將交換所有列和行。

56
00:03:14,260 --> 00:03:16,925
這本質上將你的列名稱變成索引(index)。

57
00:03:16,925 --> 00:03:19,790
然後我們可以使用.loc方法。

58
00:03:19,790 --> 00:03:21,280
這是有用的，但它很醜陋。

59
00:03:22,640 --> 00:03:26,270
由於iloc和loc用於行(row)的選擇，Pandas的開發人員

60
00:03:26,270 --> 00:03:30,226
直接在DataFrame上保留索引操作列(column)的選擇。

61
00:03:30,226 --> 00:03:33,779
在Pandas的DataFrame中，列(column)總是有一個名字。

62
00:03:33,779 --> 00:03:37,568
所以這個選擇始終是基於標籤(label)的，而不是像

63
00:03:37,568 --> 00:03:41,460
在列表(series)對像上使用方括號運算符一樣混亂。

64
00:03:41,460 --> 00:03:43,770
對於那些熟悉關聯資料庫的人來說，

65
00:03:43,770 --> 00:03:46,340
這個操作類似於列(column)的投影。

66
00:03:48,090 --> 00:03:51,200
最後，由於使用索引(indexing)運算的結果

67
00:03:51,200 --> 00:03:55,180
是DataFrame或者series，所以可以將運算鏈接在一起。

68
00:03:55,180 --> 00:03:58,243
例如，我們可以將所有Store 1費用的查詢

69
00:03:58,243 --> 00:04:01,800
所有 "Store 1" 的成本是 df.loc('Store 1', 'Cost')

70
00:04:02,850 --> 00:04:06,280
這看起來相當合理，獲取我們我們想要的結果。

71
00:04:06,280 --> 00:04:08,431
但鏈接可能會帶來一些代價，

72
00:04:08,431 --> 00:04:11,030
最好避免，如果可以使用其他方法。

73
00:04:11,030 --> 00:04:15,705
特別是，鏈接往往導致 Pandas 返回DataFrame的副本

74
00:04:15,705 --> 00:04:17,840
而不是DataFrame的視圖。

75
00:04:17,840 --> 00:04:18,880
對於選擇數據，

76
00:04:18,880 --> 00:04:22,590
這沒什麼大不了的，儘管它可能比必要的慢一點。

77
00:04:22,590 --> 00:04:25,510
如果你正在更改數據，這是一個重要的區別，

78
00:04:25,510 --> 00:04:26,559
可能是錯誤的根源。

79
00:04:27,810 --> 00:04:29,370
這裡是另一種方法。

80
00:04:29,370 --> 00:04:32,810
我們看到，.loc執行row的選擇，它可以使用兩個參數，

81
00:04:32,810 --> 00:04:35,490
row索引和column名稱列表。

82
00:04:35,490 --> 00:04:38,130
.loc也支持分離切片。

83
00:04:38,130 --> 00:04:39,634
如果我們想要選擇所有的row，

84
00:04:39,634 --> 00:04:42,721
我們可以使用一個column，表明從頭到尾一個完整的切片。

85
00:04:42,721 --> 00:04:47,150
然後添加column名稱字串，作為第二個參數。

86
00:04:47,150 --> 00:04:50,620
實際上，如果我們要包含多幾行columns，我們可以用列表來這樣做。

87
00:04:50,620 --> 00:04:53,330
Pandas只會顯示出我們要求的columns。

88
00:04:54,750 --> 00:04:56,190
這裡有一個例子，我們要求

89
00:04:56,190 --> 00:05:00,370
所有商店的名稱和費用，使用.loc運算符。

90
00:05:02,010 --> 00:05:05,290
這就是從DataFrame中選擇和投影數據，根據row和

91
00:05:05,290 --> 00:05:06,580
column標籤。

92
00:05:06,580 --> 00:05:10,120
要記住的關鍵概念是行和列，真的只是為了

93
00:05:10,120 --> 00:05:11,120
我們的方便使用。

94
00:05:11,120 --> 00:05:14,220
在這裏面只是一個雙軸有標籤的陣列(array)，而且

95
00:05:14,220 --> 00:05:15,800
轉置columns是很容易的。

96
00:05:16,830 --> 00:05:19,610
另外，仔細考慮鏈接(chaining)的問題，

97
00:05:19,610 --> 00:05:22,740
盡量避免，它可能會導致不可預知的結果。

98
00:05:22,740 --> 00:05:25,140
你的意圖是獲取數據的視圖(view)，

99
00:05:25,140 --> 00:05:27,044
而Pandas會返回給你一份副本。

100
00:05:27,044 --> 00:05:30,810
在Pandas的世界裡，做朋友的不要讓朋友用鏈接。

101
00:05:30,810 --> 00:05:33,710
所以如果你看到它，指出來，並且分享一個較不模糊的解決方案。

102
00:05:34,870 --> 00:05:38,520
現在，在我們離開討論存取DataFrames中的數據之前，

103
00:05:38,520 --> 00:05:40,060
我們來談談刪除數據。

104
00:05:41,680 --> 00:05:44,610
很容易刪除series和DataFrames的數據，

105
00:05:44,610 --> 00:05:47,090
我們可以使用drop函數來這樣做。

106
00:05:47,090 --> 00:05:52,121
此函數需要單一參數，即索引(index)或row標籤。

107
00:05:52,121 --> 00:05:55,400
這是Pandas新使用者另一個棘手的地方。

108
00:05:55,400 --> 00:05:58,480
正規的情況下，drop函數不會更改DataFrame。

109
00:05:58,480 --> 00:06:03,270
相反，返回給你刪除了指定行的DataFrame的副本。

110
00:06:03,270 --> 00:06:07,030
我們可以看到，我們原來的DataFrame還是完好無損的。

111
00:06:07,030 --> 00:06:10,960
讓我們用copy方法複製一份，然後再用drop函數在這副本。

112
00:06:10,960 --> 00:06:15,360
在Pandas中，這是一個非常典型的模式，對DataFrame進行就地更改，

113
00:06:15,360 --> 00:06:19,360
只有在需要的時候才能做，通常是在涉及index的變更上。

114
00:06:19,360 --> 00:06:20,700
所以重要的是要注意到。

115
00:06:21,950 --> 00:06:24,460
Drop有兩個有趣的可選擇的參數。

116
00:06:24,460 --> 00:06:27,240
第一個是inplace，如果設置為true，

117
00:06:27,240 --> 00:06:31,460
則DataFrame將被就地更新，而不是返回副本。

118
00:06:31,460 --> 00:06:34,680
第二個參數是axis，表示要刪除的。

119
00:06:34,680 --> 00:06:37,997
正規的情況下，該值為0，表示row的軸向。

120
00:06:37,997 --> 00:06:40,310
但是，如果要刪除column，則可以將其更改為1。

121
00:06:42,210 --> 00:06:44,670
然而，有第二種方法去刪除column。

122
00:06:44,670 --> 00:06:49,360
直接使用索引操作，使用del關鍵字。

123
00:06:50,940 --> 00:06:52,050
但是，丟棄數據的方法

124
00:06:52,050 --> 00:06:55,650
立即對DataFrame生效，並且不返回視圖。

125
00:06:56,870 --> 00:06:59,750
最後，向DataFrame添加一個新column

126
00:06:59,750 --> 00:07:02,270
與將其指定某些值一樣簡單。

127
00:07:02,270 --> 00:07:02,930
比如說，

128
00:07:02,930 --> 00:07:06,850
如果我們想要添加一個新的位置作為column，預設值為none，

129
00:07:06,850 --> 00:07:11,270
我們可以在方括弧之後，使用指派運算符來實現。

130
00:07:11,270 --> 00:07:15,274
這將立即將預設值放送到新的column。