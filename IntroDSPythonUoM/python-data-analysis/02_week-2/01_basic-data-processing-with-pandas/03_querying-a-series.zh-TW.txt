Pandas的Series(列表)可以查詢，使用索引(index)的位置或索引的標籤(label)。 正如我們所看到的，如果你不指派series的index，則位置和 標籤實際上是相同的值。 要利用數位位置查詢，從零開始，使用iloc屬性。 要通過索引標籤(label)進行查詢，可以使用loc屬性。 以下是維基百科的全國體育賽事數據。 假設我們想要列出所有的運動當我們的索引(index)，和 國家列表作為值(value)。 你可以將這些保留在dictionary中，並按照我們以前討論的方式創建一個series。 如果你想查看第四個國家， 我們將使用iloc屬性和參數,3. 如果你想了解哪個國家將高爾夫(golf)作為其全國運動， 那麼我們將使用loc屬性和參數高爾夫(golf)。 請記住，iloc和loc不是方法(method)，它們是屬性(attribute)。 所以你不用括號()來查詢它們，而是使用方括號[]， 我們稱之為索引運算符。 在Python中， 這叫做獲取(get)和設置(set)一個項目的方法，根據其使用的背景來決定。 這看起來可能有點困惑的，如果你習慣于語言在哪裡封裝在裏面的 屬性、變數和性能是常見的，比如在JAVA中。 Pandas試圖使我們的程式更具有可讀性，並提供一種 智慧語法，使用index操作符直接在series本身。 例如，如果你傳入一個整數參數， 運算子會表現得好像你想要通過iloc屬性來查詢。 如果你傳入一個物件(object)， 它將認為你想要查詢使用根據標籤(label)的loc屬性。 那麼如果你的index是整數列表會發生什麼呢？ 這有點複雜，pandas無法自動確定 你是打算通過索引位置或索引標籤進行查詢。 所以在series本身使用index操作時，你需要小心。 而更安全的選擇是更加明確，直接使用 iloc或loc屬性。 以下是使用一些新的體育數據的範例， 其中國家以整數索引。 如果我們嘗試調用s[0]，我們會得到一個key error， 因為運動列表中沒有任何項目，索引為零。 相反，如果我們想要第一個項目，我們必須顯式地調用iloc。 好的，現在我們知道如何從series中獲取數據。 我們來談談使用數據。 一個常見的工作是想考慮一series內的所有值， 我想要做一些運算 這可能是試圖找到某些數字，總結數據或 以某種方式轉換數據。 一個典型的程式設計方法，要遍歷 該series中的所有項目，並調用一個你感興趣的運算 例如，我們可以創建一個浮點值的數據組(dataframe)。 讓我們把這些看作是不同產品的價格。 我們可以寫一個小的例行程序碼，遍歷的所有 series中的項目，並將它們加一起以獲得總數。 這有效，但速度很慢。 現代電腦可以同時執行許多任務， 尤其是涉及數學的任務。 Pandas和基礎的NumPy程式庫支持一個稱為 向量化 Vectorization與NumPy庫中的大部分功能一起使用， 包括sum函數。 以下是我們如何使用NumPy sum方法來重寫程式。 首先我們需要導入numpy程式庫，然後我們調用np.sum 並傳入一個可遍歷迭代的項目。 在這裡，我們的pandas series。 現在這兩種方法產生相同的值，但是哪一種是確實更快嗎？ Jupyter筆記本有一個神奇的函數，可以幫助。 首先，我們設置一個大系列的隨機(random)數字。 你會看到使用了很多這種設置，當展示pandas技術時。 請注意，我只是用head()的方法，它減少了 列表中印出來的數量到前五個元素的數據。 實際上，我們可以驗證序列長度是正確使用len()函數。 神奇功能以百分比符號%開頭。 如果我們打入這個標誌%，然後按Tab鍵， 我們可以看到可用的魔術函數的列表。 你也可以編寫自己的魔術函數 但這不過是本課程的範圍之外。 我們實際上會使用所謂的細胞(cellular)魔術函數 這些以兩個百分比的符號開始， 並修改或包裝當前Jupyter單元中的程式。 我們要使用的函數稱為timeit。 你可能已經從名稱猜到了，此函數會運行我們的程式幾次， 來確定，平均而言，它需要多長的時間。 讓我們運行timeit，用我們原來的反覆運算程式。 你可以給timeit你希望運行的循環次數。 預設情況下，我們會使用1,000循環。 我在這裡要求timeit運行100次，因為我們正在錄製這個。 不錯蠻好的 Timeit運行這個程式，看起來好像不需要很長的時間。 現在我們來嘗試用向量化(vetorization)。 哇! 這是一個相當令人震驚的速度差異和 展示資料科學家為什麼必須要注意的並行計算的特點 並在函數功能編程方面開始思考。 在pandas和NumPy的相關的功能稱為廣播(broadcasting)。 通過broadcasting，你可以對series中的每個值應用操作， 更改series。 例如，如果我們想要對每個隨機變數增加2， 我們可以使用+=運算符號直接在列表對像上快速地執行。 在這裡，我只需要使用head運算印出前五項 首先，我想要先來介紹這門課的四位講師 做這的樣程序方式是，遍歷所有的 列表中的項目和直接增加它的數值。 很快的提一下， Pandas確實支持遍歷迭代列表項目，很類似於dictionary， 讓你容易地把數值分拆開。 但如果你發現自己反覆遍歷一列表， 你應該質疑你做的方式是否是盡可能最好的。 這裡是我們怎麼做這列表的set_value方法。 讓我們試試這兩種方法，和量它用的時間。 這是令人驚訝的 不僅是明顯的變快，而它是更簡潔和 甚至更容易去讀。 你預期的典型數學運算是向量化的，和NumPy 文檔概述了創建你自己的向量化的函數所需要怎麼做。 最後一點要注意的，在使用索引運算來存取列表資料。 .loc屬性(attribute)讓你不僅可以修改數據， 還可以添加新數據。 如果作為索引傳入的值不存在，則它會添加一個新條目。 請記住，指數可以有混合類型。 雖然重要的是，要注意在下面的類型是什麼， Pandas會根據需要，自動更改基本的NumPy類型。 這是一個使用一列表數字的例子。 我們可以添加一些新的數值，也許是一種動物，如你所知，我喜歡熊。 然後調用.loc索引操作。 我們看到數據值或索引標籤的混合類型，對於Pandas來說是沒有問題的。 到目前為止，我只顯示了索引值是唯一的 我想要結束這節課，展示一個索引值不是唯一的例子 這使得dataframe(資料框)， 從概念上講，可能不同於關聯資料庫(database)。 回顧國家和國家體育運動的問題， 事實證明，很多國家似乎都喜歡這個板球比賽。 我們回到我們原來的運動列表。 可以創建一個帶有多個條目的新列表，用 板球索引，然後使用append將它們放在一起。 使用append時，有幾個重要的注意事項。 首先，Pandas將採取你的列表， 並嘗試推斷使用最好的數據類型。 在這個例子中，一切都是字符(string)，所以這裡沒有問題。 其次，append方法實際上並沒有改變底層的列表。 而是返回一個由兩個附加在一起組成的新列表。 我們可以回溯並列印原始列表值， 看到它們沒有改變。 這是實際上的一個重大問題 新的Pandas使用者，之前習慣了物件(objects)在原處更改。 所以要當心了，不只是append，還有其他的Pandas函數功能。 最後，我們看到，當我們查詢附加在一起的列表，用板球 作為國家運動的，我們不是得到一個單一的值，而是一個列表。 這實際上是很常見的， 如果你有資料庫背景，這與表查詢非常 相似，返回集本身也是一個表(table)。 在這堂課， 我們專注於Pandas函數庫的主要數據類型之一，列表(series)。 有更多的方法(methods)與列表(series)有關聯，我們還沒有 談到。 但這些基礎下，我們會繼續進一步談到 Pandas的二維數據結構，數據框(dataframe)。 dataframe是非常相似於列表(series)，但 但包含多列數據，並且是一個結構你將要 用大部分時間使用來清理和聚合數據。 但我們討論的資料幀之前，我們助教 將提供更深入地看看如何可以使用系列物件。