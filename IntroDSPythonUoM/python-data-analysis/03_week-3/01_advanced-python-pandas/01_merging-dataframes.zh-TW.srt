1
00:00:09,082 --> 00:00:12,021
上週，我們介紹了Pandas數據處理和

2
00:00:12,021 --> 00:00:13,430
分析的程式庫。

3
00:00:13,430 --> 00:00:16,649
我們看到，是實際上兩個非常相似的核心數據結構，

4
00:00:16,649 --> 00:00:20,540
一維的列表(series)物件和二維的數據框(DataFrame)物件。

5
00:00:20,540 --> 00:00:23,579
查詢這兩個數據結構以幾種不同的方式完成，

6
00:00:23,579 --> 00:00:26,671
例如使用iloc或loc屬性進行對於行(row)的查詢，或者

7
00:00:26,671 --> 00:00:31,040
使用方括號在物件本身進行對於列(column)的查詢。

8
00:00:31,040 --> 00:00:33,810
最重要的是，我們看到一個可以查詢DataFrame和

9
00:00:33,810 --> 00:00:36,080
series物件通過布林遮蔽(boolean masking)。

10
00:00:36,080 --> 00:00:38,810
布林遮蔽是一種強大的過濾方法，

11
00:00:38,810 --> 00:00:42,730
它允許我們使用廣播來確定在我們的分析中應該保留哪些數據。

12
00:00:44,860 --> 00:00:46,080
在本週的講課中，

13
00:00:46,080 --> 00:00:50,840
我們將詳細介紹如何操作DataFrame。

14
00:00:50,840 --> 00:00:54,220
我們將探討如何使用GroupBy和Apply來減少和處理數據，

15
00:00:54,220 --> 00:00:58,420
以及如何將多個文件中的數據集合在一起。

16
00:00:58,420 --> 00:01:01,020
我們還將討論pandas一些有用的功能，

17
00:01:01,020 --> 00:01:04,970
對傳統統計分析和機器學習。

18
00:01:04,970 --> 00:01:07,160
我們從如何合併數據集開始吧。

19
00:01:07,160 --> 00:01:10,260
我們已經看到如何將新數據添加到現有的DataFrame中。

20
00:01:10,260 --> 00:01:12,910
只需使用帶有新列名稱的方括號運算符，

21
00:01:12,910 --> 00:01:16,430
只要索引被共用，數據就添加了。

22
00:01:16,430 --> 00:01:20,080
如果沒有共享索引，並且傳入一個標量值，

23
00:01:20,080 --> 00:01:24,240
那麼記住一個純量只是一個整數或一個字串。

24
00:01:24,240 --> 00:01:27,780
添加在列的新值，是以純量作為預設值。

25
00:01:27,780 --> 00:01:31,060
如果我們想為每一行分配一個不同的值呢？

26
00:01:31,060 --> 00:01:32,488
那麼它變得更棘手。

27
00:01:32,488 --> 00:01:35,500
如果我們可以將值，寫死程式到列表中，那麼Pandas將解拆解它們並

28
00:01:35,500 --> 00:01:36,940
將它們分配給行。

29
00:01:36,940 --> 00:01:39,500
但是，如果我們的列表不夠長，那麼我們不能這樣做，

30
00:01:39,500 --> 00:01:41,850
因為pandas不知道丟失的值應該去哪裡。

31
00:01:43,040 --> 00:01:44,256
這裡有個例子，這裡有個例子，

32
00:01:44,256 --> 00:01:48,160
我們以前的講課中使用了一個商店購買的DataFrame，

33
00:01:48,160 --> 00:01:51,950
其中索引(index)是商店列表，列(column)存儲購買數據。

34
00:01:51,950 --> 00:01:56,555
如果我們要在DataFrame中添加一些名為Date的新列，那沒關係。

35
00:01:56,555 --> 00:01:59,570
我們只需直接在DataFrame上使用方括號運算符，

36
00:01:59,570 --> 00:02:02,270
只要列與其餘記錄一樣長。

37
00:02:02,270 --> 00:02:04,000
如果我們要添加一些新的欄位，

38
00:02:04,000 --> 00:02:07,260
可能是一個投遞標記，這也是很容易的，因為它是一個純量。

39
00:02:08,540 --> 00:02:11,450
當我們只添加幾個項目時，會出現問題。

40
00:02:11,450 --> 00:02:14,760
為了使其工作，我們必須為Pandas提供

41
00:02:14,760 --> 00:02:18,440
足夠長的DataFrame的列表，以便可以填充每一行。

42
00:02:18,440 --> 00:02:22,035
這意味著我們必須自己輸入none值。

43
00:02:22,035 --> 00:02:24,265
如果我們每行都有一個獨特的索引，

44
00:02:24,265 --> 00:02:27,775
那麼我們可以將新的列標識分配給該系列。

45
00:02:27,775 --> 00:02:31,455
例如，如果我們在此範例中重置索引，因此DataFrame索引標記

46
00:02:31,455 --> 00:02:36,475
為0到2，那麼我們使用這些標記創建一個新的系列，我們可引用它。

47
00:02:36,475 --> 00:02:39,565
我們得到的結果是我們預期的。

48
00:02:39,565 --> 00:02:42,925
這種方法的好方面是，我們可以忽略項目我們

49
00:02:42,925 --> 00:02:46,170
不知道的，Pandas會為我們放進丟失值。

50
00:02:46,170 --> 00:02:48,650
所以這是一個非常好的方法。

51
00:02:48,650 --> 00:02:52,460
更常見的是，我們想要結合兩個較大的DataFrame在一起，

52
00:02:52,460 --> 00:02:54,650
這是一個比較複雜的。

53
00:02:54,650 --> 00:02:57,870
在我們跳入程式之前，我們需要解決一點關聯理論，

54
00:02:57,870 --> 00:03:00,600
並設定一些語言的慣例。

55
00:03:00,600 --> 00:03:02,250
這是維恩圖(Venn Daigram)。

56
00:03:02,250 --> 00:03:06,000
維恩圖通常用於顯示集合的關係

57
00:03:06,000 --> 00:03:10,210
例如，在左邊圓圈的人口是一所大學的學生。

58
00:03:10,210 --> 00:03:13,820
在右邊圈的人口是在一所大學的工作人員。

59
00:03:13,820 --> 00:03:17,327
中間的重疊地區是那些也是學生

60
00:03:17,327 --> 00:03:18,129
的工作人員。

61
00:03:18,129 --> 00:03:21,210
也許這些學生指導課程或打作業成績，

62
00:03:21,210 --> 00:03:23,990
或從事研究實驗。

63
00:03:23,990 --> 00:03:27,940
我們可以將這兩個人群視為各別的DataFrames中的索引，

64
00:03:27,940 --> 00:03:30,040
可能有Person Name的標籤。

65
00:03:30,040 --> 00:03:34,060
當我們想結合DataFrames時，我們有一些選擇。

66
00:03:34,060 --> 00:03:36,796
首先，如果我們想要所有人的名單，無論

67
00:03:36,796 --> 00:03:41,480
他們是工作人員還是學生，以及獲得所有他們的信息呢？

68
00:03:41,480 --> 00:03:44,700
在資料庫術語中，這稱為完整的外連接(full outer join)。

69
00:03:44,700 --> 00:03:46,820
在集合(set)理論中，它被稱為聯盟(union)。

70
00:03:46,820 --> 00:03:50,350
在維恩圖中，它代表了任何一個圈子的每個人。

71
00:03:51,370 --> 00:03:54,600
很可能，我們只要那些我們擁有最多

72
00:03:54,600 --> 00:03:59,010
資料的人，那些既是工作人員又是學生的人。

73
00:03:59,010 --> 00:04:01,610
在數據庫術語中，這稱為內連接(inner join)。

74
00:04:01,610 --> 00:04:03,810
或者在集合理論中，交集(intersection)。

75
00:04:03,810 --> 00:04:07,300
這在維恩圖中被表示為重疊部分，

76
00:04:07,300 --> 00:04:07,920
在每個圓的。

77
00:04:09,290 --> 00:04:13,610
好的，讓我們來看一個我們如何在Pandas中做這個的例子，

78
00:04:13,610 --> 00:04:15,169
在那裡我們將使用merge函數。

79
00:04:16,260 --> 00:04:19,020
首先我們創建兩個DataFrames，員工和學生。

80
00:04:19,020 --> 00:04:21,510
這些DataFrames有一些重疊，James和

81
00:04:21,510 --> 00:04:25,330
Sally都是學生和工作人員，但Mike和Kelly不是。

82
00:04:25,330 --> 00:04:29,870
重要的是，兩個DataFrames都按照我們要合併的值進行索引，

83
00:04:29,870 --> 00:04:30,600
叫做Name。

84
00:04:31,770 --> 00:04:33,100
如果我們想要這些的union，

85
00:04:33,100 --> 00:04:36,324
我們將調用merge，傳遞在左邊的DataFrame和在右邊的DataFrame，

86
00:04:36,324 --> 00:04:40,190
並且告訴merge我們想要使用外連接(outer join)。

87
00:04:40,190 --> 00:04:44,280
我們告訴merge，我們要用左索引和右索引作為結合列。

88
00:04:45,500 --> 00:04:48,460
我們在結果的DataFrame中看到每個人都被列出。

89
00:04:48,460 --> 00:04:50,170
而且由於Mike沒有任何role，

90
00:04:50,170 --> 00:04:53,305
而John沒有school，那些單元被列為缺失值(NaN)。

91
00:04:53,305 --> 00:04:56,585
如果我們想要得到intersection，就是

92
00:04:56,585 --> 00:05:01,405
那些也是員工的學生，我們可以將how屬性設置為inner。

93
00:05:01,405 --> 00:05:04,925
而我們設置的結果DataFrame只有James和Sally。

94
00:05:07,597 --> 00:05:11,077
現在，當合併DataFrames時，還有另外兩個常見的用例。

95
00:05:11,077 --> 00:05:13,997
兩個例子都是我們稱之為集合加法(set addition)。

96
00:05:13,997 --> 00:05:17,977
第一個是當我們想要得到所有員工的名單，不管

97
00:05:17,977 --> 00:05:19,657
他們是否是學生。

98
00:05:19,657 --> 00:05:23,457
但如果他們是學生，我們也想要獲得他們的學生細節。

99
00:05:23,457 --> 00:05:25,097
為此，我們將使用左連接(left join)。

100
00:05:26,100 --> 00:05:28,060
你可能猜測到接下來會是什麼。

101
00:05:28,060 --> 00:05:32,080
我們想要一個所有學生和他們的角色的列表，如果他們也是工作人員。

102
00:05:32,080 --> 00:05:34,750
為此，我們將使用右連接(right join)。

103
00:05:34,750 --> 00:05:37,790
合併方法有一些其他有趣的參數。

104
00:05:37,790 --> 00:05:41,410
首先，您不需要使用索引來加入，也可以使用列。這是一個例子。

105
00:05:41,410 --> 00:05:42,218
這裡有個例子，這裡有個例子，

106
00:05:50,807 --> 00:05:54,360
那麼當我們在DataFrames之間有衝突時會發生什麼？

107
00:05:54,360 --> 00:05:56,290
我們來看看，創建新的員工和

108
00:05:56,290 --> 00:06:00,000
學生的DataFrames添加了一個位置資料。

109
00:06:00,000 --> 00:06:00,950
在工作人員的DataFrame中，

110
00:06:00,950 --> 00:06:03,830
這是一個辦公室的位置，我們可以找到工作人員。

111
00:06:03,830 --> 00:06:06,335
而我們可以看到Director of HR在State Street，

112
00:06:06,335 --> 00:06:09,360
而兩個學生在Washington大街。

113
00:06:09,360 --> 00:06:10,580
但是對於學生DataFrame，

114
00:06:10,580 --> 00:06:13,160
位置資料實際上是他們的家庭地址。

115
00:06:14,310 --> 00:06:18,816
merge函數保留此資料，但附加_x或

116
00:06:18,816 --> 00:06:22,652
_y以幫助區分哪個索引與哪個列的數據有關。

117
00:06:22,652 --> 00:06:26,600
_x始終是左邊的DataFrame資料，

118
00:06:26,600 --> 00:06:29,910
而_y始終是右邊的DataFrame資料。

119
00:06:29,910 --> 00:06:32,492
你可以控制_x和

120
00:06:32,492 --> 00:06:35,520
_y的名字使用附加的參數，如果你想。

121
00:06:35,520 --> 00:06:36,470
現在你試試看。

122
00:06:36,470 --> 00:06:38,950
以下是產品和發票的DataFrame。

123
00:06:38,950 --> 00:06:41,310
該產品具有標識符和標價。

124
00:06:41,310 --> 00:06:45,110
發票列出了人員，產品，標識符和數量。

125
00:06:45,110 --> 00:06:49,243
假設我們要產生總計，我們如何將這兩個DataFrames

126
00:06:49,243 --> 00:06:53,069
加在一起，以便我們有一個列出我們需要的所有信息？

127
00:06:56,757 --> 00:07:00,558
在我們離開的DataFrames的merge之前，讓我們來談談多索引和

128
00:07:00,558 --> 00:07:02,340
多列。

129
00:07:02,340 --> 00:07:06,310
學生和工作人員的名字很可能重疊，

130
00:07:06,310 --> 00:07:07,930
但姓可能不重疊。

131
00:07:07,930 --> 00:07:11,560
在這種情況下，我們使用一個列的名單表，應該用於

132
00:07:11,560 --> 00:07:14,920
連接left_on和right_on參數的鍵。

133
00:07:14,920 --> 00:07:19,050
正如你所看到的，James Wilde和James Hammond在兩個關鍵字上都不匹配。

134
00:07:19,050 --> 00:07:22,500
所以inner連接的輸出不包括這些人，

135
00:07:22,500 --> 00:07:24,960
只有Sally Brooks被保留。

136
00:07:24,960 --> 00:07:26,531
那就是合併(merge)DataFrames。

137
00:07:26,531 --> 00:07:30,420
Pandas在該區域有更多的選擇，但我認為合併功能可能

138
00:07:30,420 --> 00:07:33,880
是最容易理解和最靈活的。

139
00:07:33,880 --> 00:07:37,060
在下一節中，我們將討論如何編寫慣用的習語Pandas，

140
00:07:37,060 --> 00:07:41,150
並深入研究操作DataFrames更高級的功能。