1
00:00:00,176 --> 00:00:03,949
在这个视频中 我将展示

2
00:00:03,949 --> 00:00:06,663
一个机器学习的例子

3
00:00:06,663 --> 00:00:08,756
它是一种非常简单的神经网络

4
00:00:08,756 --> 00:00:12,672
它将学着识别数字

5
00:00:12,672 --> 00:00:15,029
并且你能够从中观察到权值的演变过程，

6
00:00:15,082 --> 00:00:18,135
从我们运行的非常简单的学习算法中。

7
00:00:18,711 --> 00:00:20,326
所以，我们我们来看非常

8
00:00:20,326 --> 00:00:24,250
训练一个非常简单的用于识别手写形状的网络的学习算法。

9
00:00:24,250 --> 00:00:29,273
网络有两层神经元。

10
00:00:29,588 --> 00:00:31,646
它有输入神经单元。

11
00:00:31,646 --> 00:00:38,033
它们的激励表示每个像素的强度。输出神经单元的回应表示

12
00:00:38,033 --> 00:00:39,010
类别。

13
00:00:41,857 --> 00:00:43,587
我们想要的是，当我们输入

14
00:00:43,587 --> 00:00:49,611
特定的形状时，该形状的输出单元会被激活

15
00:00:51,287 --> 00:00:53,863
如果一个像素是活跃的，它要做的

16
00:00:53,863 --> 00:00:57,096
是给特定的形状投票。

17
00:00:57,096 --> 00:01:00,889
即这些形状包含这个像素。

18
00:01:00,889 --> 00:01:04,031
每个有墨水的像素可以给多个形状投票。

19
00:01:04,031 --> 00:01:09,803
每个投票可以有不同的强度，得到最多票的形状获胜。

20
00:01:09,803 --> 00:01:10,794
所以我们假设

21
00:01:10,794 --> 00:01:12,960
在输出单元之间有竞争。

22
00:01:12,960 --> 00:01:14,772
另外，一些我现在没有解释的内容

23
00:01:14,772 --> 00:01:17,951
将在接下来的课程中解释。

24
00:01:20,028 --> 00:01:24,297
所以首先，我们需要决定如何显示权重。

25
00:01:24,297 --> 00:01:29,385
非常自然地，我们可以把权重写在

26
00:01:29,385 --> 00:01:34,809
输入和输出单元的连接上。但是，

27
00:01:35,255 --> 00:01:39,309
我们需要显示成千上万个权重值。

28
00:01:39,447 --> 00:01:45,196
所以，想法是对于每个输出单元做个映射。在映射中，我们显示

29
00:01:46,180 --> 00:01:53,032
每个位置上的输入像素的连接强度

30
00:01:53,324 --> 00:01:59,375
我们用黑色和白色的斑点来表示连接的强度。这些斑点的区域代表幅值。

31
00:01:59,375 --> 00:02:09,822
他们的颜色代表正负。那么，你现在看到的初始权重只是一些小的随机值。

32
00:02:10,083 --> 00:02:18,643
现在我们要做的是给这个网络一些数据
让它学习到比随机权重更好的权值

33
00:02:19,550 --> 00:02:27,240
我们采取的方法是：给它一个图像

34
00:02:27,240 --> 00:02:33,274
然后增加从这个图像中活动的像素到正确的分类的权重

35
00:02:33,274 --> 00:02:37,942
如果只是做加法 权重只能变大最终导致每个分类

36
00:02:37,942 --> 00:02:40,782
无论我们给网络什么图像
它都将得到巨大的输入

37
00:02:40,782 --> 00:02:44,124
所以我们需要想办法控制权值

38
00:02:44,124 --> 00:02:50,311
我们要做的是减小从活跃像素到任何网络猜测的分类的权重

39
00:02:50,311 --> 00:02:53,040
减小从活跃像素到任何网络猜测的分类的权重

40
00:02:53,040 --> 00:03:00,113
所以我们确实在训练它做正确的事
而不是现在看到的有趋向于做正确的事

41
00:03:00,113 --> 00:03:04,909
如果它的确在做正确的事 
那么我们在学习规则的第一步所增加的权重

42
00:03:04,909 --> 00:03:11,358
将恰好抵消这个减法 于是什么事也没有发生
这正是我们想要的

43
00:03:12,896 --> 00:03:18,569
所以 这是初始权值 
现在我们将给这个网络几百个训练数据

44
00:03:18,569 --> 00:03:20,706
然后再来看这些权重

45
00:03:20,706 --> 00:03:25,893
现在 权重已经变了

46
00:03:25,893 --> 00:03:31,204
他们开始形成有规律的模式  现在再给它几百个训练数据

47
00:03:31,204 --> 00:03:34,871
权值有一些小的改变 接着再来几百个

48
00:03:34,871 --> 00:03:39,648
再几百个  再几百个

49
00:03:39,648 --> 00:03:43,016
现在权值已经基本上达到其终值了

50
00:03:43,186 --> 00:03:50,720
我将在后面的课时中讨论更多的细节

51
00:03:50,720 --> 00:03:54,082
但是你可以看到现在的权重看起来就像这些形状的模板

52
00:03:54,082 --> 00:04:02,128
如果你看看数字 1 对应的单位  他们并不像识别 1 的小模板
他们并不完全是模板

53
00:04:02,128 --> 00:04:04,786
如果你看看数字 9 对应的单元的权重

54
00:04:04,786 --> 00:04:08,875
他们在下半部分没有正的权重

55
00:04:08,875 --> 00:04:16,137
那是因为为了区别 9 和 7
下班部分并没有被用到

56
00:04:16,137 --> 00:04:21,710
你必须通过判断上半部分是一个圈还是一道横杠来区分它们

57
00:04:21,710 --> 00:04:26,421
所以 那些输出单元重点在于区分

58
00:04:29,928 --> 00:04:38,703
关于这个学习算法的一点是
这个网络太简单 它并不是很好的区分形状的算法

59
00:04:40,995 --> 00:04:45,707
它所学到的东西相当于每个形状的迷你模板

60
00:04:45,707 --> 00:04:53,533
然后判断哪个形状模板与输入的图形中墨迹
重叠最多 哪个图型就是胜出者

61
00:04:54,425 --> 00:05:03,043
问题是手写的数字在权重上的变化太复杂
简单的模板并不能用于识别所有形状

62
00:05:03,043 --> 00:05:13,250
你必须为数字建立允许变异的模型：
首先进行特征提取 然后再看这些特征的排列

63
00:05:14,774 --> 00:05:18,090
这里是我们刚刚提到的例子

64
00:05:18,090 --> 00:05:29,790
观察绿色方框内的这些数字2 你会发现找不到一种模板 既能够很好地匹配这些数字2 又不会错误地匹配到红色方框内的数字3

65
00:05:29,790 --> 00:05:33,721
所以这个任务不能被这样一个简单的神经网络轻易解决

66
00:05:35,025 --> 00:05:38,800
这个神经网络尽其所能也仍旧无法胜任这个任务