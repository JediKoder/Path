1
00:00:00,176 --> 00:00:03,949
В этом видео я собираюст показать вам

2
00:00:03,949 --> 00:00:06,663
пример машинного обучения

3
00:00:06,663 --> 00:00:08,756
Это очень простой тип нейросети

4
00:00:08,756 --> 00:00:12,672
и она будет учиться распознавать цифры.

5
00:00:12,672 --> 00:00:15,029
И вы сможете увидеть, как эволюционируют веса

6
00:00:15,082 --> 00:00:18,135
по мере прогона очень простого обучающего алгоритма.

7
00:00:18,711 --> 00:00:20,326
Итак, мы собираемся посмотреть на очень

8
00:00:20,326 --> 00:00:24,250
простой алгоритм обучения для тренировки очень простой сети

9
00:00:24,250 --> 00:00:29,273
распознавать рукописные формы. Сеть имеет два слоя нейронов.

10
00:00:29,588 --> 00:00:31,646
У нее есть входные нейроны

11
00:00:31,646 --> 00:00:38,033
чья активность соответствует интенсивности пикселей, и выходные нейроны, чья активность соответствует классу

12
00:00:38,033 --> 00:00:39,010
классам.

13
00:00:41,857 --> 00:00:43,587
Что мы хотим: когда мы показываем

14
00:00:43,587 --> 00:00:49,611
определенную форму, выходной нейрон для этой формы становится активным.

15
00:00:51,287 --> 00:00:53,863
Если пиксель активен, то это значит,

16
00:00:53,863 --> 00:00:57,096
что он "голосует" за определенные формы.

17
00:00:57,096 --> 00:01:00,889
А именно за формы, которые содержат этот пиксель.

18
00:01:00,889 --> 00:01:04,031
Каждый закраженный пиксель может "голосовать" за несколько форм.

19
00:01:04,031 --> 00:01:09,803
и голоса могут иметь разную интенсивность, побеждает форма, которая набирает больше всего голосов.

20
00:01:09,803 --> 00:01:10,794
Так, мы предполагаем,

21
00:01:10,794 --> 00:01:12,960
что идет соревнование между выходными элементами,

22
00:01:12,960 --> 00:01:14,772
и что всё, что я ещё не объяснил,

23
00:01:14,772 --> 00:01:17,951
я объясню в следующей лекции.

24
00:01:20,028 --> 00:01:24,297
Итак, во-первых, нам нужно решить, как отображать цифры. И

25
00:01:24,297 --> 00:01:29,385
кажется правильным записывть веса на связях между

26
00:01:29,385 --> 00:01:34,809
входными и выходными элементами.

27
00:01:35,255 --> 00:01:39,309
Нам нужно отображение, на котором мы сможем видеть значения тысяч весов.

28
00:01:39,447 --> 00:01:45,196
Таким образом, для каждого выходного элемента мы сделаем небольшую карту. И на этой карте мы покажем

29
00:01:46,180 --> 00:01:53,032
силу связи, идущей от каждого пикселя, в месте нахождения этого входного пикселя.

30
00:01:53,324 --> 00:01:59,375
И мы покажем силу связи, используя черные и белые пятнышки, чья область означает значимость

31
00:01:59,375 --> 00:02:09,822
и чей цвет означает знак. Итак, изначальные веса, которые вы видите - это просто маленькие случайным образом определенные веса.

32
00:02:10,083 --> 00:02:18,643
Теперь, мы собираемся показать этой нейросети некоторые данные и обучить её весам, которые лучше, чем случайные веса.

33
00:02:19,550 --> 00:02:27,240
Способ, на который мы собираемся посмотреть, заключается в том, что когда мы показываем изображение, мы увеличиваем веса

34
00:02:27,240 --> 00:02:33,274
от активных пикселей к правильному классу.

35
00:02:33,274 --> 00:02:37,942
Если бы мы делали только это, веса могли бы только увеличиваться и однажды каждый класс 

36
00:02:37,942 --> 00:02:40,782
получал бы огромный входной сигнал, какую бы картинку мы не нарисовали.

37
00:02:40,782 --> 00:02:44,124
Так что, нам нужен какой-то способ контроля над весами.

38
00:02:44,124 --> 00:02:50,311
Что мы собираемся делать: мы будем также уменьшать веса от активных пикселей к тем классам,

39
00:02:50,311 --> 00:02:53,040
которые становятся догадками нейросети.

40
00:02:53,040 --> 00:03:00,113
Так (мы на самом деле) обучаем её правильным вещам, а не тому, (к чему у нее) в данный момент склонность.

41
00:03:00,113 --> 00:03:04,909
Конечно, если она делает правильные вещи, тогда увеливение, которое мы делаем

42
00:03:04,909 --> 00:03:11,358
в первом шаге обучающего правила, будет полностью отменять уменьшение, и ничего не изменится, и это то, что мы хотим.

43
00:03:12,896 --> 00:03:18,569
Итак, у нас есть начальные веса. Сейчас мы покажем вам несколько сотен примеров, и затем

44
00:03:18,569 --> 00:03:20,706
посмотри на веса снова.

45
00:03:20,706 --> 00:03:25,893
Так, теперь веса изменились, они начали

46
00:03:25,893 --> 00:03:31,204
формировать правильные шаблоны. Покажем еще несколько сотен примеров.

47
00:03:31,204 --> 00:03:34,871
Веса немного изменились. Еще несколько сотен примеров.

48
00:03:34,871 --> 00:03:39,648
И еще несколько сотен примеров. Еще несколько сотен.

49
00:03:39,648 --> 00:03:43,016
И теперь веса уже довольно сильно похожи на свои финальные значения.

50
00:03:43,186 --> 00:03:50,720
Я расскажу больше в следующих лекциях о точных деталях обучающего алгоритма. Но вы можете видеть, что

51
00:03:50,720 --> 00:03:54,082
веса сейчас выглядят как маленькие шаблоны форм.

52
00:03:54,082 --> 00:04:02,128
Если вы посмотрите на веса, идущие к элементу единицы, например, одни не (выглядят) как шаблон для определения единицы, они не совсем шаблоны.

53
00:04:02,128 --> 00:04:04,786
Если посмотрите на веса, идущие к элементу девятки,

54
00:04:04,786 --> 00:04:08,875
они не имеют положительных весов в нижней половине.

55
00:04:08,875 --> 00:04:16,137
Это потому, что чтобы показать разницу между 9 и 7, веса нижней половины не очень много используются.

56
00:04:16,137 --> 00:04:21,710
Вы можете определить разницу, решая, есть ли наверху кольцо или горизонтальная линия.

57
00:04:21,710 --> 00:04:26,421
И таким образом, выходные элементы фомусируются на подобных различиях.

58
00:04:29,928 --> 00:04:38,703
Одна заметка об этом обучающем алгоритме - так как сеть очень простая, её невозможно обучить как следует различать формы. 

59
00:04:40,995 --> 00:04:45,707
То, чему она обучается - это эквивалентно тому, чтобы иметь маленькие шаблоны для каждой формы.

60
00:04:45,707 --> 00:04:53,533
И затем решать, кто победитель, основываясь на том, какой форме принадлежит шаблон, перекрываемый наибольшим количеством чернил.

61
00:04:54,425 --> 00:05:03,043
Проблема в том, что веса, в которых рукописные цифры очень варьируются, очень сложно получить просто сопоставляя шаблоны всех форм.

62
00:05:03,043 --> 00:05:13,250
Вам нужно смоделировать допустимые вариации для цифр путем, во-первых, выделения признаков и, затем, расположения этих признаков. 

63
00:05:14,774 --> 00:05:18,090
Итак, это пример, который мы уже видели.

64
00:05:18,090 --> 00:05:29,790
Если вы посмотрите на 2ки в зеленой рамке, вы увидите, что нет шаблона, который хорошо подходил бы им всем и при этом не подходил бы 3кам в красной рамке.

65
00:05:29,790 --> 00:05:33,721
Так что, задача просто не может быть решена такой простой нейросетью.

66
00:05:35,025 --> 00:05:38,800
Сеть сделала все, что могла, но не решила проблему.