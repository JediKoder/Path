1
00:00:08,408 --> 00:00:10,520
Welcome to today's tutorial,

2
00:00:10,520 --> 00:00:13,960
where we'll be looking at the time series and
date functionally in pandas.

3
00:00:15,350 --> 00:00:17,820
Pandas has four main time related classes.

4
00:00:17,820 --> 00:00:22,740
Timestamp, DatetimeIndex,
Period, and PeriodIndex.

5
00:00:22,740 --> 00:00:25,250
First, let's look at Timestamp.

6
00:00:25,250 --> 00:00:29,989
Timestamp represents a single timestamp
and associates values with points in time.

7
00:00:31,733 --> 00:00:35,665
For example,
let's create a timestamp using a string

8
00:00:35,665 --> 00:00:41,460
9/1/2016 10:05AM, and
here we have our timestamp.

9
00:00:41,460 --> 00:00:44,980
Timestamp is interchangeable with
Python's datetime in most cases.

10
00:00:46,130 --> 00:00:49,270
Suppose we weren't interested
in a specific point in time, and

11
00:00:49,270 --> 00:00:51,760
instead wanted a span of time.

12
00:00:51,760 --> 00:00:53,240
This is where Period comes into play.

13
00:00:55,230 --> 00:00:58,810
Period represents a single time span,
such as a specific day or month.

14
00:01:00,470 --> 00:01:04,470
Here we are creating a period
that is January 2016,

15
00:01:04,470 --> 00:01:09,480
and here's an example of
a period that is March 5th, 2016.

16
00:01:09,480 --> 00:01:13,720
The index of a timestamp
is DatetimeIndex.

17
00:01:13,720 --> 00:01:14,820
Let's look at a quick example.

18
00:01:16,400 --> 00:01:19,886
First, let's create our example series t1,

19
00:01:19,886 --> 00:01:25,220
we'll use the Timestamp of September 1st,
2nd and 3rd of 2016.

20
00:01:27,689 --> 00:01:31,883
When we look at the series,
each Timestamp is the index and

21
00:01:31,883 --> 00:01:36,090
has a value associated with it,
in this case, a, b and c.

22
00:01:38,330 --> 00:01:42,070
Looking at the type of our series index,
we see that it's DatetimeIndex.

23
00:01:43,740 --> 00:01:46,650
Similarly, the index of
period is PeriodIndex.

24
00:01:47,840 --> 00:01:50,140
Let's create another example series t2.

25
00:01:50,140 --> 00:01:53,990
This time, we'll use the values d,
e, and f and

26
00:01:53,990 --> 00:01:58,154
match them with the period September,
October and November 2016.

27
00:02:00,980 --> 00:02:07,490
Looking at the type of the ts2.index,
we can see that it's PeriodIndex.

28
00:02:07,490 --> 00:02:09,840
Now, let's look into how
to convert to Datetime.

29
00:02:11,950 --> 00:02:13,840
Suppose we have a list
of dates as strings.

30
00:02:14,890 --> 00:02:17,860
If we create a DataFrame using
these dates as the index.

31
00:02:17,860 --> 00:02:20,850
And some randomly generated data,
this is the DataFrame we get.

32
00:02:26,600 --> 00:02:29,140
Looking at the index we can
see that itâ€™s pretty messy and

33
00:02:29,140 --> 00:02:30,620
the dates are all in different formats.

34
00:02:31,900 --> 00:02:36,440
Using pandas to_datetime, pandas will
try to convert these to Datetime and

35
00:02:36,440 --> 00:02:37,570
put them in a standard format.

36
00:02:39,560 --> 00:02:43,330
to_datetime also has options to
change the date parse order.

37
00:02:43,330 --> 00:02:47,920
For example, we can pass in
the argument dayfirst = True to

38
00:02:47,920 --> 00:02:49,760
parse the date in European date format.

39
00:02:52,310 --> 00:02:56,049
Timedeltas are differences in times.

40
00:02:56,049 --> 00:02:59,490
We can see that when we take
the difference between September 3rd and

41
00:02:59,490 --> 00:03:00,390
September 1st,

42
00:03:00,390 --> 00:03:02,250
we get a Timedelta of two days.

43
00:03:03,580 --> 00:03:08,088
We can also do something like find what
the date and time is for 12 days and

44
00:03:08,088 --> 00:03:11,223
three hours past September 2nd,
at 8:10 AM.

45
00:03:13,800 --> 00:03:16,620
Next, let's look at a few tricks for
working with dates in a DataFrame.

46
00:03:18,730 --> 00:03:21,591
Suppose we want to look at nine
measurements, taken bi-weekly,

47
00:03:21,591 --> 00:03:22,740
every Sunday,

48
00:03:22,740 --> 00:03:23,960
starting in October 2016.

49
00:03:23,960 --> 00:03:29,555
Using date_range,
we can create this DatetimeIndex.

50
00:03:33,369 --> 00:03:37,285
Now, let's create a DataFrame using
these dates, and some random data, and

51
00:03:37,285 --> 00:03:38,621
see what we can do with it.

52
00:03:49,427 --> 00:03:53,400
First, we can check what day of
the week a specific date is.

53
00:03:53,400 --> 00:03:56,960
For example, here we can see that all
the dates in our index are on a Sunday.

54
00:03:58,360 --> 00:04:01,360
We can use diff to find the difference
between each date's value.

55
00:04:03,310 --> 00:04:06,780
Suppose we wanted to know what the mean
count is for each month in our DataFrame.

56
00:04:07,980 --> 00:04:10,671
We can do this using resample.

57
00:04:13,562 --> 00:04:17,883
We can use partial string indexing to
find values from a particular year, or

58
00:04:17,883 --> 00:04:22,480
from a particular month, or
we can even slice on a range of dates.

59
00:04:22,480 --> 00:04:25,710
For example, here we only want
the values from December 2016 onwards.

60
00:04:27,930 --> 00:04:32,010
Another cool thing we can do is change the
frequency of our dates in our DataFrame

61
00:04:32,010 --> 00:04:32,780
using asfreq.

62
00:04:35,050 --> 00:04:38,450
If we use this to change the frequency
from bi-weekly to weekly,

63
00:04:38,450 --> 00:04:41,370
we'll end up with missing
values every other week.

64
00:04:41,370 --> 00:04:43,900
So let's use the forward fill
method on those missing values.

65
00:04:45,050 --> 00:04:48,170
One last thing I wanted to briefly
touch upon is plotting time series.

66
00:04:50,600 --> 00:04:56,710
Importing matplotlib.pyplot, and using
the iPython magic %mapplotlib inline,

67
00:04:56,710 --> 00:04:59,070
will allow you to visualize
the time series in the notebook.

68
00:05:00,820 --> 00:05:03,523
In the next course,
we will learn more about understanding and

69
00:05:03,523 --> 00:05:04,747
creating visualizations.

70
00:05:04,747 --> 00:05:06,736
Thanks for watching, see you next time.