1
00:00:08,793 --> 00:00:12,780
如我們所見，列表(series)和DataFrames都可以應用索引(index)。

2
00:00:12,780 --> 00:00:15,110
索引本質上是行(row)的標籤，

3
00:00:15,110 --> 00:00:17,830
我們知道行對應於軸零(axis=0)。

4
00:00:17,830 --> 00:00:21,130
在我們的奧運數據中，我們用國家的名稱對Dataframe進行索引。

5
00:00:21,130 --> 00:00:23,740
指數可以被自動推斷，例如當我們創建新列表，

6
00:00:23,740 --> 00:00:27,230
沒有指定索引時，在這種情況下，我們獲得數值索引;

7
00:00:27,230 --> 00:00:28,980
或者可以明確設置，

8
00:00:28,980 --> 00:00:31,910
比如當我們使用字典(dictionary)創建列表時;

9
00:00:31,910 --> 00:00:36,190
或者當我們下載數據時從CSV文件時,指定標頭

10
00:00:36,190 --> 00:00:40,370
另一個選項用來設置index是使用set_index函數。

11
00:00:40,370 --> 00:00:44,590
此函數使用一個列(column)的名單，並將這些列提升為索引。

12
00:00:44,590 --> 00:00:49,338
set_index是個破壞性過程，它不保留當前的索引。

13
00:00:49,338 --> 00:00:53,020
如果要保留當前索引，則需要手動創建一個新的列，

14
00:00:53,020 --> 00:00:56,360
並從index屬性將其複製到其中。

15
00:00:56,360 --> 00:00:58,600
我們回到我們的奧運DataFrame。

16
00:00:58,600 --> 00:01:01,440
假設我們不想按照國家來索引DataFrame，

17
00:01:01,440 --> 00:01:05,660
而是要按夏季奧運中獲得的金牌數量進行來索引。

18
00:01:05,660 --> 00:01:09,070
首先，我們需要將原來的國家索引保存到新的列('country')。

19
00:01:09,070 --> 00:01:13,510
我們可以使用索引操作或具有列標籤的字串來執行此操作。

20
00:01:13,510 --> 00:01:18,015
然後我們用set_index，使用夏季金牌獲得數量column，來設置新的索引。

21
00:01:19,220 --> 00:01:23,200
你會看到，當我們從一個現有的列創建一個新的索引時，看起來

22
00:01:23,200 --> 00:01:25,910
一個新的空行被添加在第一行。

23
00:01:25,910 --> 00:01:27,670
這並不是像你看到的。

24
00:01:27,670 --> 00:01:30,640
而我們知道這一點，部分原因是，一個空值實際上將被給予

25
00:01:30,640 --> 00:01:35,140
none或NaN，如果列的數據類型是數值。

26
00:01:35,140 --> 00:01:37,680
實際發生的是索引有一個名字。

27
00:01:37,680 --> 00:01:41,140
無論列名是什麼，Jupyter筆記本會提供它

28
00:01:41,140 --> 00:01:41,710
在輸出裡。

29
00:01:42,860 --> 00:01:46,930
我們可以通過調用reset_index函數完全去除索引。

30
00:01:46,930 --> 00:01:51,378
這提升原來的索引成一個列，並創建內定的編號索引。

31
00:01:54,522 --> 00:01:59,360
Pandas的一個很好的功能是可以選擇進行多層次索引。

32
00:01:59,360 --> 00:02:02,426
這與關連資料庫系統中的複合鍵類似。

33
00:02:02,426 --> 00:02:06,450
要創建多層次索引，我們只需調用set_index，

34
00:02:06,450 --> 00:02:09,330
給一個列的列表，包含我們有興趣提升為索引的。

35
00:02:10,400 --> 00:02:13,560
Pandas將按順序搜索這些資料，找出不同的數據

36
00:02:13,560 --> 00:02:15,770
並形成綜合索引指數。

37
00:02:15,770 --> 00:02:19,520
我們經常可以發現很好的例子，在處理地理數據，

38
00:02:19,520 --> 00:02:22,200
按區域或人口統計來分類的數據。

39
00:02:22,200 --> 00:02:26,330
我們來改數據集，查看一些普查資料，以獲得更好的例子。

40
00:02:26,330 --> 00:02:28,620
該數據存儲在文件census.csv中，

41
00:02:28,620 --> 00:02:31,460
來自美國人口普查局。

42
00:02:31,460 --> 00:02:32,130
尤其是尤其是

43
00:02:32,130 --> 00:02:36,670
這是美國縣級人口數據的詳細細節。

44
00:02:36,670 --> 00:02:39,545
這是一個很好的例子，說明不同類型的數據

45
00:02:39,545 --> 00:02:41,865
可能的格式，當您嘗試清理數據集時。

46
00:02:41,865 --> 00:02:45,445
例如，在這個數據集中有兩個總結級別，

47
00:02:45,445 --> 00:02:47,665
一個包含整個國家的摘要數據。

48
00:02:47,665 --> 00:02:50,895
一個包含每個州的摘要數據，

49
00:02:50,895 --> 00:02:52,985
一個包含每個縣的摘要數據。

50
00:02:52,985 --> 00:02:58,505
我經常發現我想看到給定列中所有獨特值的列表。

51
00:02:58,505 --> 00:03:00,735
在這個DataFrame中，我們可以看到可能的獨特值在

52
00:03:00,735 --> 00:03:04,510
SUMLEV，使用unique()函數在DataFrame。

53
00:03:04,510 --> 00:03:06,780
這與SQL裡distinct運算符類似。

54
00:03:08,480 --> 00:03:11,945
在這裡，我們可以執行unique()在這個DataFrame的SUMLEV，

55
00:03:11,945 --> 00:03:15,226
看到只有兩個不同的值，即40和50.

56
00:03:15,226 --> 00:03:18,983
讓我們除掉每一行州的摘要數據，

57
00:03:18,983 --> 00:03:20,429
只保留縣級數據。

58
00:03:20,429 --> 00:03:24,003
此外，基於許多不同的原因，這數據集是很有趣味的，

59
00:03:24,003 --> 00:03:27,749
讓我們將減少我們將要查看的數據，僅包括總人口

60
00:03:27,749 --> 00:03:30,540
估計和總出生次數。

61
00:03:30,540 --> 00:03:33,440
我們可以這樣做，通過創建我們想要保留的列名稱的列表，

62
00:03:33,440 --> 00:03:37,960
然後對這列表進行投入，並將生成的DataFrame分配給我們的df變量。

63
00:03:37,960 --> 00:03:43,370
美國人口普查數據分析人口數據估計按照州和縣的方式。

64
00:03:43,370 --> 00:03:46,910
我們可以載入數據並將索引設置為州和

65
00:03:46,910 --> 00:03:50,990
縣的組合，並查看Pandas如何在DataFrame中處理它。

66
00:03:50,990 --> 00:03:53,800
我們可以這樣做，通過創建列標籤的列表，我們想要用來

67
00:03:53,800 --> 00:03:54,446
當索引的。

68
00:03:54,446 --> 00:03:59,480
然後使用此列表，用set_index並酌情指定輸出變量。

69
00:03:59,480 --> 00:04:02,780
我們在這裡看到我們有一個雙重索引，首先是州名，

70
00:04:02,780 --> 00:04:03,540
然後是縣名。

71
00:04:04,950 --> 00:04:08,540
一個直接的問題是我們如何查詢這個DataFrame。

72
00:04:08,540 --> 00:04:11,080
例如，我們以前看到loc屬性

73
00:04:11,080 --> 00:04:13,462
在DataFrame可以用多個參數。

74
00:04:13,462 --> 00:04:16,910
它可以查詢行(row)和列(column)。

75
00:04:16,910 --> 00:04:18,110
當您使用Multi-Index時，

76
00:04:18,110 --> 00:04:21,880
您必須按照要查詢的級別順序提供參數。

77
00:04:21,880 --> 00:04:24,540
在索引的內部，每列稱為一個級別，

78
00:04:24,540 --> 00:04:27,070
最外面的列為級別零。

79
00:04:27,070 --> 00:04:30,920
例如，如果我們想看到Washtenaw縣的人口結果，

80
00:04:30,920 --> 00:04:35,720
我住的地方，那麼你要將用第一個參數為密歇根州Michigan。

81
00:04:35,720 --> 00:04:38,280
你可能有興趣只比較兩個縣。

82
00:04:38,280 --> 00:04:42,130
例如，我住的Washtenaw和覆蓋Detroit的Wayne縣。

83
00:04:42,130 --> 00:04:43,900
為此，我們可以傳遞loc方法，

84
00:04:43,900 --> 00:04:47,470
一個的元組(tuple)列表(list)，描述我們希望查詢的索引。

85
00:04:47,470 --> 00:04:51,107
由於我們有一個Multi-Index的兩個值，州和縣，

86
00:04:51,107 --> 00:04:54,635
我們需要提供每個元素兩個值，作為我們的過濾列表。

87
00:05:01,324 --> 00:05:04,730
好的，這就是扼要的解釋層次索引。

88
00:05:04,730 --> 00:05:07,460
他們是Pandas程式庫的一個特殊部分，

89
00:05:07,460 --> 00:05:10,720
我認為可以使數據的管理和推理更容易。

90
00:05:10,720 --> 00:05:14,100
當然，層次標籤不僅適用於行(row)。

91
00:05:14,100 --> 00:05:18,570
例如，您可以轉置此矩陣，現在具有列(column)的層次標籤。

92
00:05:18,570 --> 00:05:21,340
投影一個具有這些標籤的列，

93
00:05:21,340 --> 00:05:23,420
正如您所期望的方式運行。