在談論如何查詢DataFrames之前， 我們需要談論布林(boolean)遮蔽(masking)。 布林遮蔽是NumPy快速高效查詢的核心。 它類似於在其他計算領域使用的遮蔽(masking)。 布林遮罩是一個陣列(atrray)，它可以是一維度像一個列表(series)，或者 二維度像DataFrame這樣的， 陣列中的每個值都是true或false。 這個陣列(array)基本上覆蓋在我們查詢的數據結構之上。 任何單元格與true都將被允許進入我們的最終結果， 任何單元格與false對齊的就不能夠。 布林遮蔽在概念上是強大的， 是高效的NumPy和Pandas查詢的基石。 這種技術在計算機科學的其他領域中被廣泛使用， 例如圖形學。 但是在其他傳統的關連資料庫中並沒有類似的， 所以我認為這裡值得一提。 創建布林遮罩通過將操作符直接應用於Pandas列表或 DataFrame對象。 例如，在我們的奧運數據集中，您可能只想看到 在夏季奧運會上獲得金牌的國家。 要構建此查詢的布林遮罩，我們投影金牌('Gold')列，使用索引運算符， 並應用比較值為大於零(>0)的運算符。 這實際上是廣播比較(comparison)運算符， 大於(>)，其結果為布林(Boolean)系列。 所得到的是有索引的系列，每個單元格是True或 False，根據一個國家是否贏得了至少一枚金牌， 並且索引是國家名稱， 所以我們建立了布林遮罩，然而這只是一半而已。 接下來我們要做的是覆蓋該遮罩(mask)在DataFrame上。 我們可以使用where函數來做到這一點。 where函數將布林遮罩作為條件，將其應用於DataFrame或series， 並返回一個相同形狀的新DataFrame或series。 我們將這個布林遮罩應用於我們的奧運數據，並創建一個DataFrame， 只有那些在夏季比賽中贏得金牌的國家。 我們看到產生的DataFrame保留了原始的索引， 只保留了滿足條件的國家/地區的數據。 所有不符合條件的國家只有NaN數據。 OK 大多數DataFrame內置的統計功能忽略NaN的值。 例如，如果我們用count()在only_gold DataFrame中， 那麼我們看到有100個國家在夏季奧運中獲得了金牌， 而如果我們用count()在原始的df DataFrame， 我們看到有147個國家總數。 通常我們想刪除那些沒有數據的行(row)。 為此，我們可以使用dropna()功能。 您可以選擇提供dropna()應該考慮的軸(axis)。 請記住，軸只是指示列(column)或行(row)， 預設值為0，這意味著行(row)。 當你發現自己在談論Pandas，說'我常常想要用'， 很可能開發人員已經包含了捷徑， 為這些常用的操作。 例如，在這個例子中， 我們實際上並不需要明確地使用where函數。 Pandas開發人員允許索引運算元 使用布林遮罩作為值，而不是列名稱列表。 語法可能看起來有點混亂，特別是如果您不習慣使用 重載(overload)運算符的程式語言， 但結果是您可以相對較快地過濾和減少DataFrames。 這裡是一個更簡潔的例子，說明我們如何查詢這個DataFrame。 當您以這種方式查詢DataFrame時，您會注意到沒有NaN。 Pandas自動過濾掉沒有值的行。 要牢記一點，如果你不習慣用布林(boolean)或位(bit)遮蔽來 減少數據 兩個布林遮罩，當進行邏輯比較運算，其輸出是 是另一個布林遮罩。 這意味著您可以鏈接一堆and/or語句 以創建更複雜的查詢，結果仍然是單個布林遮罩。 例如，我們可以創造一個遮罩(mask)為所有 在夏季奧運會上獲得金牌的國家，邏輯上或(or) 在所有冬季奧運會上獲得金牌的國家的遮罩。 如果我們在裡面看看DataFrame， 並使用length函數查看有多少行， 我們看到有101個國家在某些時候贏得了金牌。 另一個好玩的例子。 有沒有哪個國家只在冬季奧運會上贏得金牌， 從來沒有在夏季奧運會？ 這是一個回答方法。 可憐的Liechtenstein列支敦士登 幸運的是，奧運每四年一次。 我知道我將在2020年為誰歡呼加油，以贏得他們的第一個夏季金牌。 非常重要的，通常是新用者的一個問題是， 要記住，每個布林遮罩需要被包含在括號中。 由於操作順序的規則， 這可能導致不斷的挫折，如果不習慣，所以要小心。 在本講中，我們看了一下布林遮罩(Boolean masking)。 我們沒有編寫太多的程式，但是將mask應用於DataFrames是 Pandas的工作流程的核心，值得多練習。