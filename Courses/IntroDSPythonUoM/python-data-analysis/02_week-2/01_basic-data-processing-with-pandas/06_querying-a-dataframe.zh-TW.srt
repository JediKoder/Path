1
00:00:08,790 --> 00:00:11,109
在談論如何查詢DataFrames之前，

2
00:00:11,109 --> 00:00:13,900
我們需要談論布林(boolean)遮蔽(masking)。

3
00:00:13,900 --> 00:00:17,920
布林遮蔽是NumPy快速高效查詢的核心。

4
00:00:17,920 --> 00:00:21,089
它類似於在其他計算領域使用的遮蔽(masking)。

5
00:00:22,660 --> 00:00:26,420
布林遮罩是一個陣列(atrray)，它可以是一維度像一個列表(series)，或者

6
00:00:26,420 --> 00:00:28,380
二維度像DataFrame這樣的，

7
00:00:28,380 --> 00:00:32,280
陣列中的每個值都是true或false。

8
00:00:32,280 --> 00:00:36,680
這個陣列(array)基本上覆蓋在我們查詢的數據結構之上。

9
00:00:36,680 --> 00:00:40,800
任何單元格與true都將被允許進入我們的最終結果，

10
00:00:40,800 --> 00:00:43,020
任何單元格與false對齊的就不能夠。

11
00:00:44,350 --> 00:00:46,780
布林遮蔽在概念上是強大的，

12
00:00:46,780 --> 00:00:50,800
是高效的NumPy和Pandas查詢的基石。

13
00:00:50,800 --> 00:00:54,470
這種技術在計算機科學的其他領域中被廣泛使用，

14
00:00:54,470 --> 00:00:55,590
例如圖形學。

15
00:00:55,590 --> 00:00:59,940
但是在其他傳統的關連資料庫中並沒有類似的，

16
00:00:59,940 --> 00:01:02,410
所以我認為這裡值得一提。

17
00:01:02,410 --> 00:01:06,700
創建布林遮罩通過將操作符直接應用於Pandas列表或

18
00:01:06,700 --> 00:01:08,770
DataFrame對象。

19
00:01:08,770 --> 00:01:12,720
例如，在我們的奧運數據集中，您可能只想看到

20
00:01:12,720 --> 00:01:16,660
在夏季奧運會上獲得金牌的國家。

21
00:01:16,660 --> 00:01:21,280
要構建此查詢的布林遮罩，我們投影金牌('Gold')列，使用索引運算符，

22
00:01:21,280 --> 00:01:26,670
並應用比較值為大於零(>0)的運算符。

23
00:01:26,670 --> 00:01:29,900
這實際上是廣播比較(comparison)運算符，

24
00:01:29,900 --> 00:01:33,770
大於(>)，其結果為布林(Boolean)系列。

25
00:01:33,770 --> 00:01:37,480
所得到的是有索引的系列，每個單元格是True或

26
00:01:37,480 --> 00:01:41,690
False，根據一個國家是否贏得了至少一枚金牌，

27
00:01:41,690 --> 00:01:42,890
並且索引是國家名稱，

28
00:01:43,920 --> 00:01:47,380
所以我們建立了布林遮罩，然而這只是一半而已。

29
00:01:47,380 --> 00:01:50,790
接下來我們要做的是覆蓋該遮罩(mask)在DataFrame上。

30
00:01:50,790 --> 00:01:53,310
我們可以使用where函數來做到這一點。

31
00:01:53,310 --> 00:01:57,230
where函數將布林遮罩作為條件，將其應用於DataFrame或series，

32
00:01:57,230 --> 00:02:01,830
並返回一個相同形狀的新DataFrame或series。

33
00:02:01,830 --> 00:02:05,520
我們將這個布林遮罩應用於我們的奧運數據，並創建一個DataFrame，

34
00:02:05,520 --> 00:02:08,580
只有那些在夏季比賽中贏得金牌的國家。

35
00:02:09,650 --> 00:02:13,990
我們看到產生的DataFrame保留了原始的索引，

36
00:02:13,990 --> 00:02:17,750
只保留了滿足條件的國家/地區的數據。

37
00:02:17,750 --> 00:02:22,540
所有不符合條件的國家只有NaN數據。

38
00:02:22,540 --> 00:02:23,440
OK

39
00:02:23,440 --> 00:02:28,000
大多數DataFrame內置的統計功能忽略NaN的值。

40
00:02:29,330 --> 00:02:33,580
例如，如果我們用count()在only_gold DataFrame中，

41
00:02:33,580 --> 00:02:37,290
那麼我們看到有100個國家在夏季奧運中獲得了金牌，

42
00:02:37,290 --> 00:02:40,840
而如果我們用count()在原始的df DataFrame，

43
00:02:40,840 --> 00:02:43,550
我們看到有147個國家總數。

44
00:02:44,950 --> 00:02:48,630
通常我們想刪除那些沒有數據的行(row)。

45
00:02:48,630 --> 00:02:51,600
為此，我們可以使用dropna()功能。

46
00:02:51,600 --> 00:02:55,230
您可以選擇提供dropna()應該考慮的軸(axis)。

47
00:02:55,230 --> 00:02:59,020
請記住，軸只是指示列(column)或行(row)，

48
00:02:59,020 --> 00:03:01,130
預設值為0，這意味著行(row)。

49
00:03:02,410 --> 00:03:05,770
當你發現自己在談論Pandas，說'我常常想要用'，

50
00:03:05,770 --> 00:03:10,120
很可能開發人員已經包含了捷徑，

51
00:03:10,120 --> 00:03:11,830
為這些常用的操作。

52
00:03:11,830 --> 00:03:13,552
例如，在這個例子中，

53
00:03:13,552 --> 00:03:16,820
我們實際上並不需要明確地使用where函數。

54
00:03:16,820 --> 00:03:20,246
Pandas開發人員允許索引運算元

55
00:03:20,246 --> 00:03:24,594
使用布林遮罩作為值，而不是列名稱列表。

56
00:03:24,594 --> 00:03:27,988
語法可能看起來有點混亂，特別是如果您不習慣使用

57
00:03:27,988 --> 00:03:30,916
重載(overload)運算符的程式語言，

58
00:03:30,916 --> 00:03:35,150
但結果是您可以相對較快地過濾和減少DataFrames。

59
00:03:36,300 --> 00:03:40,120
這裡是一個更簡潔的例子，說明我們如何查詢這個DataFrame。

60
00:03:40,120 --> 00:03:44,060
當您以這種方式查詢DataFrame時，您會注意到沒有NaN。

61
00:03:44,060 --> 00:03:46,920
Pandas自動過濾掉沒有值的行。

62
00:03:48,480 --> 00:03:51,960
要牢記一點，如果你不習慣用布林(boolean)或位(bit)遮蔽來

63
00:03:51,960 --> 00:03:53,310
減少數據

64
00:03:53,310 --> 00:03:57,500
兩個布林遮罩，當進行邏輯比較運算，其輸出是

65
00:03:57,500 --> 00:03:59,490
是另一個布林遮罩。

66
00:03:59,490 --> 00:04:03,070
這意味著您可以鏈接一堆and/or語句

67
00:04:03,070 --> 00:04:06,980
以創建更複雜的查詢，結果仍然是單個布林遮罩。

68
00:04:08,450 --> 00:04:11,970
例如，我們可以創造一個遮罩(mask)為所有

69
00:04:11,970 --> 00:04:15,320
在夏季奧運會上獲得金牌的國家，邏輯上或(or)

70
00:04:15,320 --> 00:04:19,050
在所有冬季奧運會上獲得金牌的國家的遮罩。

71
00:04:19,050 --> 00:04:20,840
如果我們在裡面看看DataFrame，

72
00:04:20,840 --> 00:04:23,430
並使用length函數查看有多少行，

73
00:04:23,430 --> 00:04:27,100
我們看到有101個國家在某些時候贏得了金牌。

74
00:04:28,560 --> 00:04:30,180
另一個好玩的例子。

75
00:04:30,180 --> 00:04:33,870
有沒有哪個國家只在冬季奧運會上贏得金牌，

76
00:04:33,870 --> 00:04:35,890
從來沒有在夏季奧運會？

77
00:04:35,890 --> 00:04:37,192
這是一個回答方法。

78
00:04:42,971 --> 00:04:44,730
可憐的Liechtenstein列支敦士登

79
00:04:44,730 --> 00:04:47,220
幸運的是，奧運每四年一次。

80
00:04:47,220 --> 00:04:50,899
我知道我將在2020年為誰歡呼加油，以贏得他們的第一個夏季金牌。

81
00:04:52,190 --> 00:04:55,160
非常重要的，通常是新用者的一個問題是，

82
00:04:55,160 --> 00:04:59,310
要記住，每個布林遮罩需要被包含在括號中。

83
00:04:59,310 --> 00:05:01,570
由於操作順序的規則，

84
00:05:01,570 --> 00:05:05,280
這可能導致不斷的挫折，如果不習慣，所以要小心。

85
00:05:06,340 --> 00:05:08,940
在本講中，我們看了一下布林遮罩(Boolean masking)。

86
00:05:08,940 --> 00:05:12,260
我們沒有編寫太多的程式，但是將mask應用於DataFrames是

87
00:05:12,260 --> 00:05:15,050
Pandas的工作流程的核心，值得多練習。