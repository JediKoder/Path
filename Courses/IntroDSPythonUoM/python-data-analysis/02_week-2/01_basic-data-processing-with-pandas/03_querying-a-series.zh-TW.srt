1
00:00:08,923 --> 00:00:13,090
Pandas的Series(列表)可以查詢，使用索引(index)的位置或索引的標籤(label)。

2
00:00:13,090 --> 00:00:15,930
正如我們所看到的，如果你不指派series的index，則位置和

3
00:00:15,930 --> 00:00:18,500
標籤實際上是相同的值。

4
00:00:18,500 --> 00:00:23,580
要利用數位位置查詢，從零開始，使用iloc屬性。

5
00:00:23,580 --> 00:00:27,270
要通過索引標籤(label)進行查詢，可以使用loc屬性。

6
00:00:27,270 --> 00:00:31,320
以下是維基百科的全國體育賽事數據。

7
00:00:31,320 --> 00:00:34,240
假設我們想要列出所有的運動當我們的索引(index)，和

8
00:00:34,240 --> 00:00:36,190
國家列表作為值(value)。

9
00:00:36,190 --> 00:00:39,630
你可以將這些保留在dictionary中，並按照我們以前討論的方式創建一個series。

10
00:00:40,660 --> 00:00:43,140
如果你想查看第四個國家，

11
00:00:43,140 --> 00:00:47,180
我們將使用iloc屬性和參數,3.

12
00:00:47,180 --> 00:00:50,540
如果你想了解哪個國家將高爾夫(golf)作為其全國運動，

13
00:00:50,540 --> 00:00:53,630
那麼我們將使用loc屬性和參數高爾夫(golf)。

14
00:00:53,630 --> 00:00:57,060
請記住，iloc和loc不是方法(method)，它們是屬性(attribute)。

15
00:00:57,060 --> 00:01:00,629
所以你不用括號()來查詢它們，而是使用方括號[]，

16
00:01:00,629 --> 00:01:02,850
我們稱之為索引運算符。

17
00:01:02,850 --> 00:01:03,550
在Python中，

18
00:01:03,550 --> 00:01:06,840
這叫做獲取(get)和設置(set)一個項目的方法，根據其使用的背景來決定。

19
00:01:07,970 --> 00:01:11,750
這看起來可能有點困惑的，如果你習慣于語言在哪裡封裝在裏面的

20
00:01:11,750 --> 00:01:15,220
屬性、變數和性能是常見的，比如在JAVA中。

21
00:01:15,220 --> 00:01:19,510
Pandas試圖使我們的程式更具有可讀性，並提供一種

22
00:01:19,510 --> 00:01:24,900
智慧語法，使用index操作符直接在series本身。

23
00:01:24,900 --> 00:01:27,600
例如，如果你傳入一個整數參數，

24
00:01:27,600 --> 00:01:32,390
運算子會表現得好像你想要通過iloc屬性來查詢。

25
00:01:32,390 --> 00:01:33,640
如果你傳入一個物件(object)，

26
00:01:33,640 --> 00:01:37,220
它將認為你想要查詢使用根據標籤(label)的loc屬性。

27
00:01:38,400 --> 00:01:42,080
那麼如果你的index是整數列表會發生什麼呢？

28
00:01:42,080 --> 00:01:44,630
這有點複雜，pandas無法自動確定

29
00:01:44,630 --> 00:01:49,470
你是打算通過索引位置或索引標籤進行查詢。

30
00:01:49,470 --> 00:01:53,140
所以在series本身使用index操作時，你需要小心。

31
00:01:53,140 --> 00:01:57,430
而更安全的選擇是更加明確，直接使用

32
00:01:57,430 --> 00:01:58,870
iloc或loc屬性。

33
00:02:00,380 --> 00:02:02,980
以下是使用一些新的體育數據的範例，

34
00:02:02,980 --> 00:02:05,255
其中國家以整數索引。

35
00:02:05,255 --> 00:02:07,864
如果我們嘗試調用s[0]，我們會得到一個key error，

36
00:02:07,864 --> 00:02:12,080
因為運動列表中沒有任何項目，索引為零。

37
00:02:12,080 --> 00:02:15,910
相反，如果我們想要第一個項目，我們必須顯式地調用iloc。

38
00:02:18,040 --> 00:02:20,690
好的，現在我們知道如何從series中獲取數據。

39
00:02:20,690 --> 00:02:23,150
我們來談談使用數據。

40
00:02:23,150 --> 00:02:26,361
一個常見的工作是想考慮一series內的所有值，

41
00:02:26,361 --> 00:02:28,650
我想要做一些運算

42
00:02:28,650 --> 00:02:31,620
這可能是試圖找到某些數字，總結數據或

43
00:02:31,620 --> 00:02:33,290
以某種方式轉換數據。

44
00:02:34,330 --> 00:02:37,700
一個典型的程式設計方法，要遍歷

45
00:02:37,700 --> 00:02:42,380
該series中的所有項目，並調用一個你感興趣的運算

46
00:02:42,380 --> 00:02:46,040
例如，我們可以創建一個浮點值的數據組(dataframe)。

47
00:02:46,040 --> 00:02:49,130
讓我們把這些看作是不同產品的價格。

48
00:02:49,130 --> 00:02:52,060
我們可以寫一個小的例行程序碼，遍歷的所有

49
00:02:52,060 --> 00:02:54,309
series中的項目，並將它們加一起以獲得總數。

50
00:02:55,320 --> 00:02:57,310
這有效，但速度很慢。

51
00:02:57,310 --> 00:03:01,200
現代電腦可以同時執行許多任務，

52
00:03:01,200 --> 00:03:03,460
尤其是涉及數學的任務。

53
00:03:04,460 --> 00:03:08,447
Pandas和基礎的NumPy程式庫支持一個稱為

54
00:03:08,447 --> 00:03:09,320
向量化

55
00:03:10,540 --> 00:03:14,100
Vectorization與NumPy庫中的大部分功能一起使用，

56
00:03:14,100 --> 00:03:15,380
包括sum函數。

57
00:03:16,560 --> 00:03:19,990
以下是我們如何使用NumPy sum方法來重寫程式。

58
00:03:19,990 --> 00:03:24,423
首先我們需要導入numpy程式庫，然後我們調用np.sum

59
00:03:24,423 --> 00:03:26,035
並傳入一個可遍歷迭代的項目。

60
00:03:26,035 --> 00:03:27,750
在這裡，我們的pandas series。

61
00:03:29,210 --> 00:03:33,640
現在這兩種方法產生相同的值，但是哪一種是確實更快嗎？

62
00:03:33,640 --> 00:03:36,920
Jupyter筆記本有一個神奇的函數，可以幫助。

63
00:03:36,920 --> 00:03:39,750
首先，我們設置一個大系列的隨機(random)數字。

64
00:03:39,750 --> 00:03:43,700
你會看到使用了很多這種設置，當展示pandas技術時。

65
00:03:43,700 --> 00:03:46,590
請注意，我只是用head()的方法，它減少了

66
00:03:46,590 --> 00:03:50,540
列表中印出來的數量到前五個元素的數據。

67
00:03:50,540 --> 00:03:54,920
實際上，我們可以驗證序列長度是正確使用len()函數。

68
00:03:54,920 --> 00:03:57,322
神奇功能以百分比符號%開頭。

69
00:03:57,322 --> 00:03:59,530
如果我們打入這個標誌%，然後按Tab鍵，

70
00:03:59,530 --> 00:04:02,580
我們可以看到可用的魔術函數的列表。

71
00:04:02,580 --> 00:04:04,433
你也可以編寫自己的魔術函數

72
00:04:04,433 --> 00:04:07,450
但這不過是本課程的範圍之外。

73
00:04:07,450 --> 00:04:10,725
我們實際上會使用所謂的細胞(cellular)魔術函數

74
00:04:10,725 --> 00:04:12,530
這些以兩個百分比的符號開始，

75
00:04:12,530 --> 00:04:15,860
並修改或包裝當前Jupyter單元中的程式。

76
00:04:15,860 --> 00:04:18,440
我們要使用的函數稱為timeit。

77
00:04:18,440 --> 00:04:21,740
你可能已經從名稱猜到了，此函數會運行我們的程式幾次，

78
00:04:21,740 --> 00:04:24,270
來確定，平均而言，它需要多長的時間。

79
00:04:25,300 --> 00:04:27,880
讓我們運行timeit，用我們原來的反覆運算程式。

80
00:04:27,880 --> 00:04:31,050
你可以給timeit你希望運行的循環次數。

81
00:04:31,050 --> 00:04:33,395
預設情況下，我們會使用1,000循環。

82
00:04:33,395 --> 00:04:36,840
我在這裡要求timeit運行100次，因為我們正在錄製這個。

83
00:04:37,980 --> 00:04:38,762
不錯蠻好的

84
00:04:38,762 --> 00:04:42,310
Timeit運行這個程式，看起來好像不需要很長的時間。

85
00:04:42,310 --> 00:04:43,940
現在我們來嘗試用向量化(vetorization)。

86
00:04:45,230 --> 00:04:45,880
哇!

87
00:04:45,880 --> 00:04:48,190
這是一個相當令人震驚的速度差異和

88
00:04:48,190 --> 00:04:52,670
展示資料科學家為什麼必須要注意的並行計算的特點

89
00:04:52,670 --> 00:04:54,850
並在函數功能編程方面開始思考。

90
00:04:56,140 --> 00:04:59,660
在pandas和NumPy的相關的功能稱為廣播(broadcasting)。

91
00:04:59,660 --> 00:05:03,220
通過broadcasting，你可以對series中的每個值應用操作，

92
00:05:03,220 --> 00:05:04,080
更改series。

93
00:05:05,080 --> 00:05:08,920
例如，如果我們想要對每個隨機變數增加2，

94
00:05:08,920 --> 00:05:14,460
我們可以使用+=運算符號直接在列表對像上快速地執行。

95
00:05:14,460 --> 00:05:17,870
在這裡，我只需要使用head運算印出前五項

96
00:05:17,870 --> 00:05:18,389
首先，我想要先來介紹這門課的四位講師

97
00:05:19,910 --> 00:05:22,650
做這的樣程序方式是，遍歷所有的

98
00:05:22,650 --> 00:05:26,220
列表中的項目和直接增加它的數值。

99
00:05:26,220 --> 00:05:27,605
很快的提一下，

100
00:05:27,605 --> 00:05:30,870
Pandas確實支持遍歷迭代列表項目，很類似於dictionary，

101
00:05:30,870 --> 00:05:33,310
讓你容易地把數值分拆開。

102
00:05:33,310 --> 00:05:35,660
但如果你發現自己反覆遍歷一列表，

103
00:05:35,660 --> 00:05:38,980
你應該質疑你做的方式是否是盡可能最好的。

104
00:05:40,200 --> 00:05:43,330
這裡是我們怎麼做這列表的set_value方法。

105
00:05:44,490 --> 00:05:46,656
讓我們試試這兩種方法，和量它用的時間。

106
00:06:00,959 --> 00:06:02,165
這是令人驚訝的

107
00:06:02,165 --> 00:06:05,415
不僅是明顯的變快，而它是更簡潔和

108
00:06:05,415 --> 00:06:07,785
甚至更容易去讀。

109
00:06:07,785 --> 00:06:12,476
你預期的典型數學運算是向量化的，和NumPy

110
00:06:12,476 --> 00:06:17,053
文檔概述了創建你自己的向量化的函數所需要怎麼做。

111
00:06:17,053 --> 00:06:21,710
最後一點要注意的，在使用索引運算來存取列表資料。

112
00:06:21,710 --> 00:06:25,234
.loc屬性(attribute)讓你不僅可以修改數據，

113
00:06:25,234 --> 00:06:26,707
還可以添加新數據。

114
00:06:26,707 --> 00:06:31,710
如果作為索引傳入的值不存在，則它會添加一個新條目。

115
00:06:31,710 --> 00:06:34,050
請記住，指數可以有混合類型。

116
00:06:34,050 --> 00:06:37,550
雖然重要的是，要注意在下面的類型是什麼，

117
00:06:37,550 --> 00:06:41,430
Pandas會根據需要，自動更改基本的NumPy類型。

118
00:06:42,560 --> 00:06:45,840
這是一個使用一列表數字的例子。

119
00:06:45,840 --> 00:06:49,610
我們可以添加一些新的數值，也許是一種動物，如你所知，我喜歡熊。

120
00:06:49,610 --> 00:06:52,610
然後調用.loc索引操作。

121
00:06:52,610 --> 00:06:57,500
我們看到數據值或索引標籤的混合類型，對於Pandas來說是沒有問題的。

122
00:06:59,540 --> 00:07:04,320
到目前為止，我只顯示了索引值是唯一的

123
00:07:04,320 --> 00:07:07,390
我想要結束這節課，展示一個索引值不是唯一的例子

124
00:07:07,390 --> 00:07:09,860
這使得dataframe(資料框)，

125
00:07:09,860 --> 00:07:12,210
從概念上講，可能不同於關聯資料庫(database)。

126
00:07:13,450 --> 00:07:16,320
回顧國家和國家體育運動的問題，

127
00:07:16,320 --> 00:07:19,690
事實證明，很多國家似乎都喜歡這個板球比賽。

128
00:07:19,690 --> 00:07:21,760
我們回到我們原來的運動列表。

129
00:07:21,760 --> 00:07:25,310
可以創建一個帶有多個條目的新列表，用

130
00:07:25,310 --> 00:07:29,130
板球索引，然後使用append將它們放在一起。

131
00:07:29,130 --> 00:07:32,380
使用append時，有幾個重要的注意事項。

132
00:07:32,380 --> 00:07:34,410
首先，Pandas將採取你的列表，

133
00:07:34,410 --> 00:07:37,000
並嘗試推斷使用最好的數據類型。

134
00:07:37,000 --> 00:07:39,840
在這個例子中，一切都是字符(string)，所以這裡沒有問題。

135
00:07:41,140 --> 00:07:45,050
其次，append方法實際上並沒有改變底層的列表。

136
00:07:45,050 --> 00:07:50,100
而是返回一個由兩個附加在一起組成的新列表。

137
00:07:50,100 --> 00:07:53,730
我們可以回溯並列印原始列表值，

138
00:07:53,730 --> 00:07:55,190
看到它們沒有改變。

139
00:07:56,230 --> 00:07:58,360
這是實際上的一個重大問題

140
00:07:58,360 --> 00:08:03,240
新的Pandas使用者，之前習慣了物件(objects)在原處更改。

141
00:08:03,240 --> 00:08:07,400
所以要當心了，不只是append，還有其他的Pandas函數功能。

142
00:08:08,970 --> 00:08:12,580
最後，我們看到，當我們查詢附加在一起的列表，用板球

143
00:08:12,580 --> 00:08:17,520
作為國家運動的，我們不是得到一個單一的值，而是一個列表。

144
00:08:17,520 --> 00:08:19,330
這實際上是很常見的，

145
00:08:19,330 --> 00:08:22,930
如果你有資料庫背景，這與表查詢非常

146
00:08:22,930 --> 00:08:27,020
相似，返回集本身也是一個表(table)。

147
00:08:28,110 --> 00:08:28,810
在這堂課，

148
00:08:28,810 --> 00:08:33,730
我們專注於Pandas函數庫的主要數據類型之一，列表(series)。

149
00:08:33,730 --> 00:08:36,630
有更多的方法(methods)與列表(series)有關聯，我們還沒有

150
00:08:36,630 --> 00:08:37,250
談到。

151
00:08:37,250 --> 00:08:39,838
但這些基礎下，我們會繼續進一步談到

152
00:08:39,838 --> 00:08:43,510
Pandas的二維數據結構，數據框(dataframe)。

153
00:08:43,510 --> 00:08:46,230
dataframe是非常相似於列表(series)，但

154
00:08:46,230 --> 00:08:49,620
但包含多列數據，並且是一個結構你將要

155
00:08:49,620 --> 00:08:53,000
用大部分時間使用來清理和聚合數據。

156
00:08:54,560 --> 00:08:58,460
但我們討論的資料幀之前，我們助教

157
00:08:58,460 --> 00:09:02,870
將提供更深入地看看如何可以使用系列物件。