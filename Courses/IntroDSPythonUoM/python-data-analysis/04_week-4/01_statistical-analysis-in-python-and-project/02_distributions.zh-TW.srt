1
00:00:08,701 --> 00:00:11,210
讓我們從討論分佈(distribution)開始吧。

2
00:00:11,210 --> 00:00:13,280
我們從最常用的硬幣測試開始。

3
00:00:13,280 --> 00:00:17,230
當一個硬幣翻轉時，它有一個落的頭部向上的可能性，和

4
00:00:17,230 --> 00:00:19,430
一個落的尾巴向上的可能性。

5
00:00:19,430 --> 00:00:23,120
如果我們翻轉硬幣多次，我們會收集一些數據，頭部和

6
00:00:23,120 --> 00:00:24,900
尾巴向上的次數，

7
00:00:24,900 --> 00:00:28,040
直覺地，我們知道我們得到頭部的次數

8
00:00:28,040 --> 00:00:31,600
將相當於我們得到尾巴的次數，用一個公平的硬幣。

9
00:00:31,600 --> 00:00:34,250
如果你翻了硬幣一百次，

10
00:00:34,250 --> 00:00:38,690
你每次都得到頭部，你可能會懷疑這枚硬幣的公平性。

11
00:00:38,690 --> 00:00:42,689
我們可以將這個硬幣的每次翻轉的結果作為隨機(random)變數來考慮。

12
00:00:43,950 --> 00:00:48,020
當我們可以一起考慮所有可能的隨機變數的集合時，

13
00:00:48,020 --> 00:00:50,370
我們稱之為一個分佈(distribution)。

14
00:00:50,370 --> 00:00:53,290
在這種情況下，分佈被稱為二項式(binomial)，

15
00:00:53,290 --> 00:00:57,230
因為有兩個可能的輸出，頭或尾。

16
00:00:57,230 --> 00:01:00,770
這也是一個離散值(discreet)分佈的例子，因為只有

17
00:01:00,770 --> 00:01:05,020
使用類別(category)，頭和尾，而不是實數。

18
00:01:06,135 --> 00:01:09,100
Numpy 實際上有一些內建的分佈

19
00:01:09,100 --> 00:01:12,950
讓我們可以隨機翻轉硬幣，用給定的參數。

20
00:01:12,950 --> 00:01:13,650
讓我們試試看吧。

21
00:01:14,650 --> 00:01:18,830
這裡我們從NumPy二項式(binomial)分佈中計算一個數字

22
00:01:18,830 --> 00:01:20,380
我們有兩個參數要傳入：

23
00:01:20,380 --> 00:01:23,460
第一個是我們希望運行的次數。

24
00:01:23,460 --> 00:01:28,200
第二個是我們得到零的機會，
我們這裡將使用它來代表頭

25
00:01:28,200 --> 00:01:30,330
我們來運行一輪這個模擬。

26
00:01:31,420 --> 00:01:32,000
太好了，

27
00:01:32,000 --> 00:01:35,880
所以如果你在Jupyter筆記本上跟著，
你可能會得到一個0或1

28
00:01:35,880 --> 00:01:38,420
一半的人得到了一個與我所得到的值一樣的值。

29
00:01:39,680 --> 00:01:41,760
如果我們運行模擬一千次，

30
00:01:41,760 --> 00:01:43,690
將結果除以一千？

31
00:01:43,690 --> 00:01:46,510
那麼你看到的數字很接近0.5，這

32
00:01:46,510 --> 00:01:49,740
意味著我們有一半的時間我們有一個頭，
有一半的時間，我們有一個尾巴。

33
00:01:50,990 --> 00:01:55,760
當然，均勻加權(even weighted)二項式分佈只是一個簡單的例子。

34
00:01:55,760 --> 00:01:59,120
我們也可以具有不均勻加權的二項式分佈。

35
00:01:59,120 --> 00:02:03,710
例如，當我今天在拍攝時，有龍捲風的機會是什麼

36
00:02:03,710 --> 00:02:06,200
即使我們這裡有龍捲風，機率也很低

37
00:02:06,200 --> 00:02:10,150
也許有百分之幾的機率

38
00:02:10,150 --> 00:02:14,740
我們可以把它放進二項式分佈的加權值在NumPy中

39
00:02:14,740 --> 00:02:19,020
如果我們跑10萬次，我們看到有非常少的龍捲風事件。

40
00:02:20,460 --> 00:02:23,550
你可能會想知道為什麼我說這麼簡單和

41
00:02:23,550 --> 00:02:25,150
直觀的分佈。

42
00:02:25,150 --> 00:02:27,620
我的意思是說，我們都明白翻轉硬幣，

43
00:02:27,620 --> 00:02:30,120
作為孩子，當我們不得不做出重要決定的時候
。

44
00:02:31,220 --> 00:02:34,870
但是我想顯示的是，計算工具開始允許

45
00:02:34,870 --> 00:02:38,510
我們模擬世界的現象，有助於我們回答問題。

46
00:02:38,510 --> 00:02:40,590
我可以告訴你們這個背後的數學，

47
00:02:40,590 --> 00:02:42,770
我們可以計算出概率。

48
00:02:42,770 --> 00:02:46,470
但是模擬本質上是另一種形式的查詢。

49
00:02:46,470 --> 00:02:48,330
我們再來一個例子。

50
00:02:48,330 --> 00:02:51,940
讓我們說，龍捲風在Ann Arbor發生的機會，在任何一天

51
00:02:51,940 --> 00:02:55,130
是1％，不管一年中任何的時間

52
00:02:55,130 --> 00:02:58,030
這比現實的高，但更快的演示。

53
00:02:58,030 --> 00:03:00,970
讓我們說，如果有一個龍捲風，我要遠離窗戶並

54
00:03:00,970 --> 00:03:04,620
躲避，然後第二天再回來做錄音

55
00:03:04,620 --> 00:03:07,355
那麼連續兩天發生龍捲風的機率是甚麼？

56
00:03:08,680 --> 00:03:12,540
那麼我們可以使用NumPy中的二項式分佈來模擬這個

57
00:03:13,580 --> 00:03:17,990
這裡我們創建一個空列表，我們創建一些潛在的龍捲風事件，通過

58
00:03:17,990 --> 00:03:21,490
問NumPy二項式函數，和使用我們龍捲風的機率

59
00:03:21,490 --> 00:03:26,700
我們會做這一百萬次，這只是稍微少於3000年的事件。

60
00:03:28,080 --> 00:03:30,840
這個過程稱為分佈採樣(sampling)。

61
00:03:31,920 --> 00:03:34,360
現在我們可以寫一個循環(loop)來經歷列表，找出

62
00:03:34,360 --> 00:03:37,240
兩個相鄰的一對1，這意味著

63
00:03:37,240 --> 00:03:40,820
持續兩天有龍捲風

64
00:03:40,820 --> 00:03:46,880
我們看到，最終大概有102天的龍捲風事件(持續兩天)，在這3000年的時間里。

65
00:03:46,880 --> 00:03:49,440
坦白說，對我來說還是太多了。

66
00:03:49,440 --> 00:03:53,690
我的觀點是，現代計算能力使我們能夠非常

67
00:03:53,690 --> 00:03:58,370
快速地模擬，不同的參數對分佈的影響。

68
00:03:58,370 --> 00:04:00,530
導致一種新的理解問題的方式。

69
00:04:00,530 --> 00:04:03,520
你不必解決所有的數學問題，你可以

70
00:04:03,520 --> 00:04:07,380
很經常模擬問題，並觀察結果。

71
00:04:08,410 --> 00:04:11,430
在接下來的講課中，我們將再談一下分佈。