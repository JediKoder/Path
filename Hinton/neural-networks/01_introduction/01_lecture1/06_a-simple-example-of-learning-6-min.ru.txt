В этом видео я собираюст показать вам пример машинного обучения Это очень простой тип нейросети и она будет учиться распознавать цифры. И вы сможете увидеть, как эволюционируют веса по мере прогона очень простого обучающего алгоритма. Итак, мы собираемся посмотреть на очень простой алгоритм обучения для тренировки очень простой сети распознавать рукописные формы. Сеть имеет два слоя нейронов. У нее есть входные нейроны чья активность соответствует интенсивности пикселей, и выходные нейроны, чья активность соответствует классу классам. Что мы хотим: когда мы показываем определенную форму, выходной нейрон для этой формы становится активным. Если пиксель активен, то это значит, что он "голосует" за определенные формы. А именно за формы, которые содержат этот пиксель. Каждый закраженный пиксель может "голосовать" за несколько форм. и голоса могут иметь разную интенсивность, побеждает форма, которая набирает больше всего голосов. Так, мы предполагаем, что идет соревнование между выходными элементами, и что всё, что я ещё не объяснил, я объясню в следующей лекции. Итак, во-первых, нам нужно решить, как отображать цифры. И кажется правильным записывть веса на связях между входными и выходными элементами. Нам нужно отображение, на котором мы сможем видеть значения тысяч весов. Таким образом, для каждого выходного элемента мы сделаем небольшую карту. И на этой карте мы покажем силу связи, идущей от каждого пикселя, в месте нахождения этого входного пикселя. И мы покажем силу связи, используя черные и белые пятнышки, чья область означает значимость и чей цвет означает знак. Итак, изначальные веса, которые вы видите - это просто маленькие случайным образом определенные веса. Теперь, мы собираемся показать этой нейросети некоторые данные и обучить её весам, которые лучше, чем случайные веса. Способ, на который мы собираемся посмотреть, заключается в том, что когда мы показываем изображение, мы увеличиваем веса от активных пикселей к правильному классу. Если бы мы делали только это, веса могли бы только увеличиваться и однажды каждый класс получал бы огромный входной сигнал, какую бы картинку мы не нарисовали. Так что, нам нужен какой-то способ контроля над весами. Что мы собираемся делать: мы будем также уменьшать веса от активных пикселей к тем классам, которые становятся догадками нейросети. Так (мы на самом деле) обучаем её правильным вещам, а не тому, (к чему у нее) в данный момент склонность. Конечно, если она делает правильные вещи, тогда увеливение, которое мы делаем в первом шаге обучающего правила, будет полностью отменять уменьшение, и ничего не изменится, и это то, что мы хотим. Итак, у нас есть начальные веса. Сейчас мы покажем вам несколько сотен примеров, и затем посмотри на веса снова. Так, теперь веса изменились, они начали формировать правильные шаблоны. Покажем еще несколько сотен примеров. Веса немного изменились. Еще несколько сотен примеров. И еще несколько сотен примеров. Еще несколько сотен. И теперь веса уже довольно сильно похожи на свои финальные значения. Я расскажу больше в следующих лекциях о точных деталях обучающего алгоритма. Но вы можете видеть, что веса сейчас выглядят как маленькие шаблоны форм. Если вы посмотрите на веса, идущие к элементу единицы, например, одни не (выглядят) как шаблон для определения единицы, они не совсем шаблоны. Если посмотрите на веса, идущие к элементу девятки, они не имеют положительных весов в нижней половине. Это потому, что чтобы показать разницу между 9 и 7, веса нижней половины не очень много используются. Вы можете определить разницу, решая, есть ли наверху кольцо или горизонтальная линия. И таким образом, выходные элементы фомусируются на подобных различиях. Одна заметка об этом обучающем алгоритме - так как сеть очень простая, её невозможно обучить как следует различать формы. То, чему она обучается - это эквивалентно тому, чтобы иметь маленькие шаблоны для каждой формы. И затем решать, кто победитель, основываясь на том, какой форме принадлежит шаблон, перекрываемый наибольшим количеством чернил. Проблема в том, что веса, в которых рукописные цифры очень варьируются, очень сложно получить просто сопоставляя шаблоны всех форм. Вам нужно смоделировать допустимые вариации для цифр путем, во-первых, выделения признаков и, затем, расположения этих признаков. Итак, это пример, который мы уже видели. Если вы посмотрите на 2ки в зеленой рамке, вы увидите, что нет шаблона, который хорошо подходил бы им всем и при этом не подходил бы 3кам в красной рамке. Так что, задача просто не может быть решена такой простой нейросетью. Сеть сделала все, что могла, но не решила проблему.